<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CMU 14-445 Project#0(2024 Fall) C++ Primer</title>
      <link href="/posts/428c6b54.html"/>
      <url>/posts/428c6b54.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lab0-C-PrimerPrimer"><a href="#Lab0-C-PrimerPrimer" class="headerlink" title="Lab0  C++ PrimerPrimer"></a>Lab0  C++ PrimerPrimer</h1><h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>首先致谢CMU-db无私将这门质量极高、资源极齐全的数据库课程，以及相关基础设施（GradeScope, Discord）和课程资料（Lectures, Notes, Homework）完全开源,让一个在本科数据库课程上只学会了抽象理念和SQL语句的孩子，能踏上一条自学之路（手动狗头）<br>其次,感谢<a href="https://csdiy.wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/15445/">CS自学指南</a>,将计算机领域的众多好课分享给我们.</p><p>本专题将详尽地记录2024 Fall对应Lecture和Lab的学习经历.</p><h3 id="课程链接"><a href="#课程链接" class="headerlink" title="课程链接"></a>课程链接</h3><p><strong>课程主页</strong>:<a href="https://15445.courses.cs.cmu.edu/fall2024/">https://15445.courses.cs.cmu.edu/fall2024/</a><br><strong>Discord</strong>:<a href="https://discord.com/channels/724929902075445281/752529819148877904">https://discord.com/channels/724929902075445281/752529819148877904</a><br><strong>Gradescope</strong>:<a href="https://www.gradescope.com/courses/817458">https://www.gradescope.com/courses/817458</a> Entry Code: <code>WWWJZ5</code> (学校记得改成CMU)</p><blockquote><p>In exchange for making this available to the public, we ask that you DO NOT make your project implementations public on Github or other source code repositories.</p></blockquote><p><strong>让我们开始吧.</strong></p><p>本篇博客记录Lab概览和<code>Project #0</code>.</p><h3 id="Lab概览"><a href="#Lab概览" class="headerlink" title="Lab概览"></a>Lab概览</h3><blockquote><p>以下摘自CS指南:</p></blockquote><p>这门课的亮点在于 <code>CMU Database Group</code> 专门为此课开发了一个教学用的关系型数据库 <code>bustub</code>，并要求你对这个数据库的组成部分进行修改，实现上述部件的功能。</p><p>具体来说，在 <code>15-445</code> 中,你需要在四个 <code>Project</code> 的推进中，实现一个面向磁盘的传统关系型数据库 Bustub 中的部分关键组件。</p><p>包括 <code>Buffer Pool Manager</code> (内存管理), <code>B Plus Tree</code> (存储引擎), <code>Query Executors &amp; Query Optimizer</code> (算子们 &amp; 优化器), <code>Concurrency Control</code> (并发控制)，分别对应 <code>Project #1</code> 到 <code>Project #4</code>。</p><p>值得一提的是，同学们在实现的过程中可以通过 <code>shell.cpp</code> 编译出 <code>bustub-shell</code> 来实时地观测自己实现部件的正确与否，正反馈非常足。</p><p>此外 <code>bustub</code> 作为一个 <code>C++</code> 编写的中小型项目涵盖了程序构建、代码规范、单元测试等众多要求，可以作为一个优秀的开源项目学习。</p><p>本篇从<code>Project #0</code>开始.</p><h3 id="Project-0-2024-Fall"><a href="#Project-0-2024-Fall" class="headerlink" title="Project #0 (2024 Fall)"></a>Project #0 (2024 Fall)</h3><p>2024 Fall的预实验,集中于理解和实现一个基于概率统计的<strong>大数据基数统计</strong>算法–HyperLoglog;在此过程中,熟悉<code>C++</code>的基本应用.</p><p><code>C++</code>的基本知识可见以下两篇博客:<br><a href="/post1/">C++中的引用、移动语义、模板、包装类、迭代器和命名空间</a><br><a href="/post2/">C++标准库：容器、动态内存、同步原语</a></p><p>我们从HyperLogLog的算法理论开始.</p><h4 id="HyperLogLog算法"><a href="#HyperLogLog算法" class="headerlink" title="HyperLogLog算法"></a>HyperLogLog算法</h4><h5 id="什么情景产生了HyperLogLog？"><a href="#什么情景产生了HyperLogLog？" class="headerlink" title="什么情景产生了HyperLogLog？"></a>什么情景产生了HyperLogLog？</h5><p>假设您有一个大型元素数据集，其中包含从一组基数 n 中选择的重复条目，并且想要查找 n，即<strong>基数（不同元素的数量）</strong>。例如，我们希望计算在给定的一周内访问过 Facebook 的不同用户数量，其中每个人每天登录多次。这将产生<strong>具有许多重复项的大型数据集</strong>。显而易见的方法（例如对元素进行排序，或简单地维护所看到的唯一元素集）是不切实际的，因为它们要么计算量太大，要么需要太多内存。如何处理呢？让我们逐步思考：</p><h5 id="一个简单的估计器"><a href="#一个简单的估计器" class="headerlink" title="一个简单的估计器"></a>一个简单的估计器</h5><p>我们需要一个输出估计值的算法（误差在合理范围内）。首先，生成一个具有重复条目的假设数据集如下：</p><ol><li>生成 n 个均匀分布在 0 和 1 之间的数字；</li><li>将一些数字随机复制任意次数；</li><li>对上述数据集，随机排序。<br>使用哈希函数（哈希值被规范化并在 0 和 1 之间均匀分布），设最小的哈希值为$y_{min}&#x3D;hash(x)$，<strong>将唯一条目的数量估计为1&#x2F;y_{min}.</strong><br><img src="/posts/428c6b54/image-4.png"><br>然而，估计结果依赖于最小哈希值，而最小哈希值可能恰好太小，从而夸大了我们的估计。因此该方法具有高度可变性。</li></ol><h5 id="概率计数"><a href="#概率计数" class="headerlink" title="概率计数"></a>概率计数</h5><p>为了减少之前方法中的高可变性，我们可以通过<strong>计算哈希值二进制表示中，开头的零位数</strong>来改进。<br><img src="/posts/428c6b54/image-5.png"><br>平均而言，每$2^k$个不同条目，将出现$k$个连续的零序列，因此转为记录：最长的连续零序列的长度。即：</p><p>集合{${x_1,…,x_M}$}的基数为$2^R$，其中：$R&#x3D;max${$\rho(x_1),…,\rho(x_M)$}，$\rho(x_1)$为$hash(x_i)$的二进制表示中，前导0的数目。</p><p>此方法有两个缺点：</p><ol><li>只能提供基数的 2 的幂估计，即结果只可能是：1，2，4，8，…</li><li>如果恰巧遇到一个有太多连续前导0的条目，将产生极不准确的基数估计。</li></ol><h5 id="提高准确性：LogLog，采用多个估计量"><a href="#提高准确性：LogLog，采用多个估计量" class="headerlink" title="提高准确性：LogLog，采用多个估计量"></a>提高准确性：LogLog，采用多个估计量</h5><p>上一个方法中，只采用了一个估计量，即：最大连续前导零数。为了改进，我们<strong>采用多个独立估计器，并对结果取平均</strong>，以减少单个估计器的方差。<br><img src="/posts/428c6b54/image-6.png"><br>可以通过使用$m$个独立的哈希函数实现这点，分别计算出$R_1,…,R_m$，取算数平均，作为$R$的估计值。</p><p>但是该方法对于每个条目，均需计算其相对于每个哈希函数的哈希值，计算上太昂贵。能不能采用单个哈希函数解决呢？</p><p>学者们提出的一个解决方案是：<strong>使用哈希值的前k位作为桶的索引；计算剩余部分的最长连续 0 序列</strong>。</p><p>如下图，假设我们传入数据的哈希值为<code>1011 011101101100000</code>。</p><ol><li>使用最左边的四个位<code>(k=4)</code>作为桶索引，它告诉我们要更新哪个存储桶（十进制为 &#x3D; 11）；</li><li>在剩余部分中，获取右侧的最长连续 0序列，此时该序列长度为 5；</li><li>因此，使用 16 个存储桶，将存储桶编号 11 更新为值 5，如下所示。<br><img src="/posts/428c6b54/image-7.png"></li></ol><p>通过拥有$m$个桶，我们模拟了拥有$m$个不同哈希函数的情况。基数估计公式如下：</p><p>$CARDINALITY_{LogLog}&#x3D;constant · m · 2^{\frac{1}{m}\sum_{j&#x3D;1}^{N}R_j}$</p><p>对于 m 个桶，这会将估计器的标准误差降低到大约 $\frac{1.3}{\sqrt{m}}$。</p><blockquote><p>对于2048个桶，每个桶5位（最多可以记录32个连续0），则足以记录高达$2^{27}$的基数，只占用2048*5&#x3D;1.2KB的内存（平均错误率大约2.8%）</p></blockquote><p>更多可见以下文章:<br><a href="https://zhuanlan.zhihu.com/p/110364156">https://zhuanlan.zhihu.com/p/110364156</a></p><h4 id="Lab整体实现思路"><a href="#Lab整体实现思路" class="headerlink" title="Lab整体实现思路"></a>Lab整体实现思路</h4><p>在实际应用中，一些系统将最左侧的 1 位的位置存储在寄存器中（MSB），而另一些系统则存储最右侧连续零的个数（LSB）。在这个项目中：</p><ul><li>Task 1 采用前者;Task 2 采用后者.</li></ul><h5 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h5><p><code>HyperLoglog</code>定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @brief Cardinality value. */</span>  </span><br><span class="line"><span class="type">size_t</span> cardinality_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Number of bits. */</span></span><br><span class="line"><span class="type">int16_t</span> num_bits_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Number of Registers. */</span></span><br><span class="line"><span class="type">uint16_t</span> num_registers_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Registers. */</span> </span><br><span class="line">std::vector&lt;<span class="type">uint64_t</span>&gt; registers_;</span><br></pre></td></tr></table></figure><ul><li>初始化<code>HyperLogLog&lt;KeyType&gt;::HyperLogLog(int16_t n_bits)</code>传入的<code>n_bits</code>是寄存器索引位数,寄存器总数为<code>2^n_bits</code>.</li><li>将哈希值转为64位二进制表示;</li><li>哈希值表示中:<ul><li>寄存器索引:从高到底的前<code>n_bits</code>位:即<code>[BITSET_CAPACITY-num_bits_, BITSET_CAPACITY-1]</code>;</li><li>计算左侧第一个1的位置,需从:<code>BITSET_CAPACITY - num_bits_ - 1</code>开始,从高位向低位查找;</li></ul></li><li>寄存器当前索引对应元素的更新逻辑:如果”左侧第一个1的位置”比当前元素大,则更新.</li></ul><h5 id="Task2-Presto实现-密集结构"><a href="#Task2-Presto实现-密集结构" class="headerlink" title="Task2 Presto实现:密集结构"></a>Task2 Presto实现:密集结构</h5><p>使用两个桶,即将最右侧连续零的数量这一数据,拆成两部分存储:</p><ul><li><code>Dense Bucket</code>（密集桶）: 一个固定大小的数组，存储最低位的几个比特（leading bits）</li><li><code>Overflow Bucket</code>（溢出桶）: 一个哈希表:键为桶索引(和密集桶索引相同),值为超出密集桶最大容量的高位比特信息，避免溢出。<br><img src="/posts/428c6b54/image-9.png"><br>如上图：如果某个值的二进制表示中，右侧连续<code>0</code>的数量为<code>33</code>，其二进制形式为<code>0100001</code>。在这种情况下，会将其拆分成两部分，首先是3个<code>MSB</code>（最高有效位）<code>010</code>，接着是4个<code>LSB</code>（最低有效位）<code>0001</code>。<code>0001</code>将存储在密集桶（Dense Bucket）中，而<code>MSB</code>部分<code>010</code>将存储在溢出桶（Overflow Bucket）中。</li></ul><p><code>HyperLogLogPresto</code>中定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** @brief Capacity of the bitset stream. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSET_CAPACITY 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Dense bucket size. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DENSE_BUCKET_SIZE 4</span></span><br><span class="line"><span class="comment">/** @brief Overflow bucket size. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW_BUCKET_SIZE 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Number of leading bits. */</span></span><br><span class="line"><span class="type">int16_t</span> n_leading_bits_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Number of Buckets. */</span></span><br><span class="line"><span class="type">uint16_t</span> num_buckets_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Structure holding dense buckets (or also known as registers). */</span></span><br><span class="line">std::vector&lt;std::bitset&lt;DENSE_BUCKET_SIZE&gt;&gt; dense_bucket_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Structure holding overflow buckets. */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">uint16_t</span>, std::bitset&lt;OVERFLOW_BUCKET_SIZE&gt;&gt; overflow_bucket_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @brief Storing cardinality value */</span></span><br><span class="line"><span class="type">uint64_t</span> cardinality_;</span><br></pre></td></tr></table></figure><p>桶中元素的更新如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前的连续0数量更大：更新桶的值</span></span><br><span class="line"><span class="keyword">if</span> ((dense_bucket_[bucket_index].<span class="built_in">to_ullong</span>() + ((overflow_bucket_[bucket_index].<span class="built_in">to_ullong</span>()) &lt;&lt; <span class="number">4</span>)) &lt;</span><br><span class="line">    num_trailing_zeros) &#123;</span><br><span class="line">    <span class="function">std::bitset&lt;OVERFLOW_BUCKET_SIZE&gt; <span class="title">overflow_value</span><span class="params">(num_trailing_zeros &gt;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     DENSE_BUCKET_SIZE)</span></span>;  <span class="comment">// 取后4位之前的部分（转为二进制表示）</span></span><br><span class="line">    <span class="function">std::bitset&lt;DENSE_BUCKET_SIZE&gt; <span class="title">dense_value</span><span class="params">(num_trailing_zeros &amp;</span></span></span><br><span class="line"><span class="params"><span class="function">                                               ((<span class="number">1</span> &lt;&lt; DENSE_BUCKET_SIZE) - <span class="number">1</span>))</span></span>;  <span class="comment">// 取后4位（转为二进制表示）</span></span><br><span class="line"></span><br><span class="line">    dense_bucket_[bucket_index] = dense_value;</span><br><span class="line">    overflow_bucket_[bucket_index] = overflow_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键细节和易错点"><a href="#关键细节和易错点" class="headerlink" title="关键细节和易错点"></a>关键细节和易错点</h4><h5 id="无符号-有符号整型的处理"><a href="#无符号-有符号整型的处理" class="headerlink" title="无符号&#x2F;有符号整型的处理"></a>无符号&#x2F;有符号整型的处理</h5><p>极易出错!!!疯狂踩坑(哭泣).<br>计算<code>cardinality</code>:头文件<code>registers_</code>中声明的是<code>vector&lt;uint64_t&gt;</code>,运用其中的元素<code>reg</code>计算:<code>z += pow(2, -reg);</code></p><p>这里<code>pow(2, -reg)</code>会变成<code>inf</code>,即出现了<strong>整数下溢</strong>的bug.警惕:无符号类型不能为负!</p><p>因此应使用<code>z += 1.0/pow(2, reg);</code></p><h5 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h5><ol><li>样例<code>EdgeTest1</code>测试了构造函数中传入的实参<code>n_bits</code>为负的情况:</li></ol><p>寄存器数目为负数是无意义的.因此构造函数应写为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HyperLogLog&lt;KeyType&gt;::<span class="built_in">HyperLogLog</span>(<span class="type">int16_t</span> n_bits) : <span class="built_in">cardinality_</span>(<span class="number">0</span>), <span class="built_in">num_bits_</span>(n_bits &gt; <span class="number">0</span> ? n_bits : <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>样例<code>EdgeTest2</code>, <code>PrestoCase2</code>测试了<code>n_bits</code>或<code>n_leading_bits</code>为0的情况:</li></ol><p>这时寄存器数组<code>registers_</code>长度为<code>1&lt;&lt;0=1</code>, 注意计算寄存器索引&#x2F;桶索引时:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int16_t</span> register_index =</span><br><span class="line">      num_bits_ == <span class="number">0</span> ? <span class="number">0</span> : <span class="built_in">static_cast</span>&lt;<span class="type">int16_t</span>&gt;((bset.<span class="built_in">to_ullong</span>()) &gt;&gt; (BITSET_CAPACITY - num_bits_));</span><br><span class="line"><span class="type">int16_t</span> bucket_index =</span><br><span class="line">      n_leading_bits_ == <span class="number">0</span> ? <span class="number">0</span> : <span class="built_in">static_cast</span>&lt;<span class="type">int16_t</span>&gt;((bset.<span class="built_in">to_ullong</span>()) &gt;&gt; (BITSET_CAPACITY - n_leading_bits_));</span><br></pre></td></tr></table></figure><p><code>bset.to_ullong()</code> 返回一个 <code>unsigned long long</code> 类型的值，这个类型通常是 <code>64</code> 位. <code>num_bits_=0</code>时会溢出.</p><h4 id="测试提交流程"><a href="#测试提交流程" class="headerlink" title="测试提交流程"></a>测试提交流程</h4><h5 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h5><ol><li>创建开发环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake -DCMAKE_BUILD_TYPE=Debug ..</span><br><span class="line">$ make -j`<span class="built_in">nproc</span>`</span><br></pre></td></tr></table></figure><ol start="2"><li>本地测试</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make -j$(<span class="built_in">nproc</span>) hyperloglog_test</span><br><span class="line">$ ./test/hyperloglog_test</span><br></pre></td></tr></table></figure><p><img src="/posts/428c6b54/image-10.png"></p><h5 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h5><ol><li><code>build</code>目录下输入:<code>make submit-p0</code>,生成zip文件;</li><li>到上一层目录,执行<code>python3 gradescope_sign.py</code>,生成打分文件;</li></ol><p>这里会遇到一个问题:<br>压缩包里的内容,正常应该是用于覆盖源文件的两个<code>.h</code>文件和<code>.cpp</code>文件(即我们写的),但压缩包里似乎并不是.</p><p>此时是build打包时出了问题,我们去看看它的<code>Makefile</code>,找到<code>submit-p0</code>对应的文件路径:<br><img src="/posts/428c6b54/image-11.png"><br>去<code>CMakeFiles/submit-p0.dir/build.make</code>里找到真正打包的东西,改成我们想要的:<br><img src="/posts/428c6b54/image-12.png"></p><h5 id="格式检查"><a href="#格式检查" class="headerlink" title="格式检查"></a>格式检查</h5><p>这一步必须,否则不符合标准代码风格,提交到Gradescope也是0分:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make format</span><br><span class="line">make check-lint</span><br><span class="line">make check-clang-tidy-p0</span><br></pre></td></tr></table></figure><p>记我报过的错:</p><h6 id="变量命名-readability-identifier-naming"><a href="#变量命名-readability-identifier-naming" class="headerlink" title="变量命名(readability-identifier-naming)"></a>变量命名(readability-identifier-naming)</h6><p>根据常见的 C++ 编码规范，变量应该使用小写字母并采用下划线分隔（即蛇形命名法）.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> z = <span class="number">0.0</span>;  <span class="comment">// 将 Z 修改为 z</span></span><br><span class="line"><span class="function">std::bitset&lt;OVERFLOW_BUCKET_SIZE&gt; <span class="title">overflow_value</span><span class="params">(num_trailing_zeros &gt;&gt; <span class="number">4</span>)</span></span>;  <span class="comment">// 将 overflow_value_ 修改为 overflow_value</span></span><br></pre></td></tr></table></figure><h6 id="类型名重复-modernize-use-auto"><a href="#类型名重复-modernize-use-auto" class="headerlink" title="类型名重复(modernize-use-auto)"></a>类型名重复(modernize-use-auto)</h6><p>原本使用了显式的类型名<code>std::bitset&lt;BITSET_CAPACITY&gt;</code>,而 <code>Clang-Tidy</code> 建议使用 <code>auto</code> 来简化代码,避免显式重复类型名:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> bset = std::<span class="built_in">bitset</span>&lt;BITSET_CAPACITY&gt;(hash);  <span class="comment">// 使用 auto 来推导类型</span></span><br></pre></td></tr></table></figure><h6 id="register-与关键字冲突（readability-identifier-naming）"><a href="#register-与关键字冲突（readability-identifier-naming）" class="headerlink" title="register 与关键字冲突（readability-identifier-naming）"></a>register 与关键字冲突（readability-identifier-naming）</h6><p>在 C++ 中，<code>register</code> 是一个关键字，不能作为变量名。因此，<code>register_</code> 是一个不推荐的命名方式;将其修改为 <code>reg</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> z = <span class="number">0.0</span>;  <span class="comment">// 修改 Z 为 z</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;reg : registers_) &#123;  <span class="comment">// 修改 register_ 为 reg</span></span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p><code>Project#0</code>终于完成啦!为C++的语法特性困扰了好久,呜呜呜.</p><p>不过完成是一个好的开始,继续前进!</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
          <category> CMU 14-445 </category>
          
          <category> C++ Primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象程序设计</title>
      <link href="/posts/d43f49ad.html"/>
      <url>/posts/d43f49ad.html</url>
      
        <content type="html"><![CDATA[<p>本篇隶属C++ Primer中类设计工具专题，当前集中于面向对象程序设计。</p><h1 id="什么是面向对象编程？"><a href="#什么是面向对象编程？" class="headerlink" title="什么是面向对象编程？"></a>什么是面向对象编程？</h1><p>在面向对象编程（缩写为OOP）中，重点是创建程序定义的数据类型，<strong>这些数据类型既包含属性，也包含一组定义明确的行为</strong>。OOP中的“对象”一词，是指我们可以从此类类型中<strong>实例化</strong>的对象。<br>面向对象编程的核心理念是：<strong>数据抽象，继承和动态绑定</strong>。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>基类</strong>：位于层次关系中的根部，定义所有类共同的成员变量和成员函数；<br><strong>派生类</strong>：通过继承自动接收基类的成员函数和成员变量；可添加想要的其他函数或成员变量。</p><ul><li><strong>类派生列表</strong>：明确指出当前派生类是从哪个基类继承而来，示例：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_Quote</span> : <span class="keyword">public</span> Quote&#123;<span class="comment">// Bulk_Quote继承Quote</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h3><h4 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">Quote</span>(cosn std::string &amp;book, <span class="type">double</span> sales_price):<span class="built_in">bookNo</span>(book),<span class="built_in">price</span>(sales_price)&#123;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;<span class="comment">// 返回给定书籍的销售总额</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span></span>&#123;<span class="comment">// 虚函数：派生类改写，使用不同的折扣计算方法</span></span><br><span class="line"><span class="keyword">return</span> n*price;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()=<span class="keyword">default</span>;<span class="comment">// 对析构函数进行动态绑定</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">std::string bookNo;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">double</span> price=<span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么要将基类的析构函数定义为虚函数？<br>解答：当派生类中需要回收内存时，如果析构函数不是virtual，则不会触发动态绑定，只会调用基类的析构函数（而非子类的析构函数）那么：子类资源无法正确释放，导致内存泄露</p></blockquote><h5 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h5><p>基类定义成员函数时，需区分以下两种情况：</p><ol><li><p>派生类直接继承、不要改变的函数；（<strong>编译时</strong>解析，执行与派生类细节无关）</p></li><li><p>派生类进行覆盖的函数：定义为<strong>虚函数</strong></p></li></ol><ul><li><strong>运行时解析</strong>：使用基类指针&#x2F;引用调用虚函数时，根据其绑定类型对象类型的不同，确定执行的版本。</li></ul><hr><h5 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h5><p>C++通过 public、protected、private 三个关键字来控制成员变ᰁ和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。</p><ol><li><p><strong>类的内部</strong>：无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。</p></li><li><p><strong>类的外部</strong>：只能通过对象访问public属性的成员，不能访问private, protected属性的成员。</p></li><li><p><strong>派生类</strong>：派生类可以访问基类的public, protected成员，不能访问private成员。</p></li></ol><h4 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h4><h5 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h5><p>派生类首先使用基类的构造函数，初始化其从基类继承的部分；然后按照声明的顺序，依次初始化派生类的成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc):<span class="built_in">Quote</span>(book, p),<span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc)&#123;&#125;</span><br></pre></td></tr></table></figure><p>如上例，将前两个参数传递给<code>Quote</code>的构造函数，由其初始化<code>Bulk_quote</code>的基类部分（<code>bookNo</code>和<code>price</code>两个成员）；再初始化由派生类直接定义的<code>min_qty</code>和<code>discount</code>成员。</p><h5 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h5><p>如果基类定义了一个<strong>静态成员</strong>，则：整个继承体系中，<strong>只存在该成员的唯一定义</strong>；每个静态成员变量，只存在唯一实例。</p><h5 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h5><p>声明包含类名，不包括派生列表（派生列表应该在定义中出现）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buik_quote</span>:<span class="keyword">public</span> Quote;<span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>;<span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h5 id="防止继承的发生：final"><a href="#防止继承的发生：final" class="headerlink" title="防止继承的发生：final"></a>防止继承的发生：<code>final</code></h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDerived</span> <span class="keyword">final</span> &#123;&#125;<span class="comment">// NoDerived不能作为基类</span></span><br></pre></td></tr></table></figure><h4 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h4><h5 id="不存在下行的隐式类型转换（但存在上行的类型转换）"><a href="#不存在下行的隐式类型转换（但存在上行的类型转换）" class="headerlink" title="不存在下行的隐式类型转换（但存在上行的类型转换）"></a>不存在下行的隐式类型转换（但存在上行的类型转换）</h5><ul><li>上行转换：把派⽣类的指针或引⽤，转换成基类表示</li><li>下行转换：把基类的指针或引⽤，转换为派⽣类表示</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP=&amp;base;<span class="comment">// 错误</span></span><br><span class="line">Bulk_quote&amp; bulkRef=base;<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>即使基类指针绑定的是派生类对象，也不能执行从基类向派生类的转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP=&amp;bulk;<span class="comment">// 基类指针绑定派生类对象</span></span><br><span class="line">Bulk_quote *bulkP=itemP;<span class="comment">//错误：也不能执行基类向派生类的转换</span></span><br></pre></td></tr></table></figure><blockquote><p>对比两种C++强制类型转换：</p><ol><li><code>static_cast</code>：<strong>没有运行时类型检查</strong><ul><li>上行转换（派生类转基类）安全</li><li>下行转换（基类转派生类）不安全：没有动态检查</li></ul></li><li><code>dynamic_cast</code>：下行转换时，具有类型检查（信息在虚函数中）的功能，⽐<code>static_cast</code>更安全。</li></ol></blockquote><h5 id="上行的自动类型转换，只对指针或引用有效（对对象无效）"><a href="#上行的自动类型转换，只对指针或引用有效（对对象无效）" class="headerlink" title="上行的自动类型转换，只对指针或引用有效（对对象无效）"></a>上行的自动类型转换，只对指针或引用有效（对对象无效）</h5><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><h4 id="虚函数性质"><a href="#虚函数性质" class="headerlink" title="虚函数性质"></a>虚函数性质</h4><ol><li><p>基类声明的虚函数，在所有派生类中均为虚函数；</p></li><li><p>派生类中重写虚函数时：派生类中形参类型与该函数在基类中形参必须严格匹配。</p><blockquote><p>加了<code>override</code>说明符但形参列表不同：编译器报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span>:B&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;<span class="comment">//正确：与B中f1匹配</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;<span class="comment">// 错误：形参不匹配</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;<span class="comment">// 错误：f3不是虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不加<code>override</code>说明符，函数名相同但形参列表不同：合法，不会覆盖基类中版本，视作两个独立的函数</p></blockquote></li><li><p>基类中声明为<code>final</code>的函数，派生类中不能重写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span>:B&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D3</span>:D2&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;<span class="comment">// 正确：覆盖从B中继承的虚函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;<span class="comment">// 错误：D2中f1已声明为final</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>派生类强行调用基类中的虚函数版本：使用作用域运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> undiscounted=baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// 在编译时解析：无论baseP绑定的对象类型是什么，强行调用Quote的net_price版本</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="虚函数的实现：虚函数表"><a href="#虚函数的实现：虚函数表" class="headerlink" title="虚函数的实现：虚函数表"></a>虚函数的实现：虚函数表</h4><ul><li><p><strong>虚函数表</strong>：每个类（包括抽象类）都有⼀个虚表，其中包含了该类的虚函数的地址。</p></li><li><p><strong>虚指针</strong>：每个对象都包含⼀个指向其类的虚表的指针，这个指针被称为虚指针（vptr）。</p></li></ul><p>当调⽤⼀个虚函数时，编译器会使⽤对象的虚指针查找虚表，并通过虚表中的函数地址来执⾏相应的虚函数。这就是为什么在运⾏时，可以根据实际对象类型来确定调⽤哪个函数的原因。</p><h4 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h4><p>C++中的多态性通过虚函数（virtual function）和虚函数表（vtable）实现。多态性<strong>允许在基类类型的指针或引⽤上调⽤派⽣类对象的函数</strong>：调用虚函数时执行<strong>动态绑定</strong>：运行时解析，执行的函数版本与绑定对象匹配。</p><h6 id="基类声明虚函数"><a href="#基类声明虚函数" class="headerlink" title="基类声明虚函数"></a>基类声明虚函数</h6><p>使⽤ <code>virtual</code> 关键字，以便派⽣类重写这些函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 基类的默认实现</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="派生类重写虚函数"><a href="#派生类重写虚函数" class="headerlink" title="派生类重写虚函数"></a>派生类重写虚函数</h6><p>在派⽣类中重写基类中声明的虚函数，使⽤ <code>override</code> 关键字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 派⽣类的实现</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="使用基类指针或引用，指向派生类对象"><a href="#使用基类指针或引用，指向派生类对象" class="headerlink" title="使用基类指针或引用，指向派生类对象"></a>使用基类指针或引用，指向派生类对象</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape* shapePtr = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br></pre></td></tr></table></figure><h6 id="调用虚函数：运行时解析"><a href="#调用虚函数：运行时解析" class="headerlink" title="调用虚函数：运行时解析"></a>调用虚函数：运行时解析</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shapePtr-&gt;<span class="built_in">draw</span>();</span><br></pre></td></tr></table></figure><blockquote><p>虚函数表：编译器在对象的内存布局中维护了⼀个虚函数表，其中存储了指向实际函数的指针。这个表在运⾏时⽤于动态查找调⽤的函数。</p></blockquote><h3 id="抽象基类：不能被实例化的类"><a href="#抽象基类：不能被实例化的类" class="headerlink" title="抽象基类：不能被实例化的类"></a>抽象基类：不能被实例化的类</h3><blockquote><p>类比Java中的abstrct类；纯虚函数类比Java中的abstract方法</p></blockquote><p>抽象类是不能被实例化的类，其主要⽬的是：<strong>提供⼀个接⼝，供派⽣类继承和实现</strong>。</p><p>抽象类中可以包含普通的成员函数、数据成员和构造函数，但它<strong>必须包含⾄少⼀个纯虚函数</strong>:即在声明中使⽤ <code>virtual</code>关键字，并赋予函数⼀个 <code>= 0</code> 的纯虚函数。</p><p><strong>派⽣类必须实现抽象类中的纯虚函数，否则它们也会成为抽象类。</strong></p><h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>通过与虚函数的对比来说明。</p><ol><li><p><strong>没有实现</strong>：纯虚函数没有函数体，只有函数声明，无默认实现。</p><ul><li>虚函数<strong>有实现</strong>：有函数声明和实现，即在基类中可以提供默认实现。</li></ul></li><li><p><strong>强制覆盖</strong>：<strong>派⽣类必须提供纯虚函数的具体实现</strong>，否则它们也会成为抽象类。</p><ul><li>虚函数<strong>可选实现：</strong> 派⽣类可以选择是否覆盖虚函数。如果派⽣类没有提供实现，将使⽤基类的默认实现。</li></ul></li><li><p><strong>禁止实例化</strong>：包含虚函数的类（即抽象基类）无法实例化。</p><ul><li>虚函数的类<strong>允许实例化</strong></li></ul></li><li><p><strong>用<code>=0</code>声明</strong>：</p><ul><li>虚函数用<strong>virtual声明</strong></li></ul></li><li><p><strong>为接口提供规范</strong>，供派生类具体实现。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// 纯虚函数，没有具体实现</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureVirtualFunction</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"> <span class="comment">// 普通成员函数可以有具体实现</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">commonFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 具体实现</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><h4 id="protected成员"><a href="#protected成员" class="headerlink" title="protected成员"></a>protected成员</h4><p><code>protected</code>关键字，是介于<code>public</code>和<code>private</code>之间的产物。</p><ol><li><p>和<code>private</code>成员的相似点：<code>protected</code>和<code>private</code>成员，对于类的用户均为不可访问；</p></li><li><p>和<code>public</code>成员的相似点：（基类的）<code>protected</code>和<code>public</code>成员，<strong>对于派生类的成员和友元可访问</strong></p></li><li><p>派生类的成员和友元，<strong>只能通过派生类对象</strong>（不能通过基类对象），访问基类的<code>protected</code>成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> prot_mem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;<span class="comment">// 能访问Sneaky::prot_mem</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;<span class="comment">// 不能访问Base::prot_mem</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span></span>&#123;s.j=s.prot_mem=<span class="number">0</span>;&#125;<span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span></span>&#123;b.prot_mem=<span class="number">0</span>;&#125;<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="public-private-protected继承"><a href="#public-private-protected继承" class="headerlink" title="public, private, protected继承"></a>public, private, protected继承</h4><p>派生类对继承而得的成员的访问权限受两个因素影响：</p><ol><li><p>基类中<strong>该成员的访问说明符</strong>：影响<strong>派生类的成员和友元</strong>的访问权限</p><blockquote><p> <strong>派生类的成员和友元</strong>的访问权限，只与基类中访问说明符有关，不受派生列表中访问说明符的影响：如下例中：<code>Priv_Derv</code>中可访问<code>prot_mem</code>（尽管派生列表中为<code>private</code>）</p></blockquote></li><li><p>派生列表中的访问说明符：影响派生类用户（包括派生类的派生类）的访问权限</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;<span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> prot_mem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span> priv_mem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pub_Derv</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;<span class="comment">//正确：派生类可访问基类的protected成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Priv_Derv</span>:<span class="keyword">private</span> Base&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;<span class="comment">// 正确：当前派生类不受派生列表中private的影响</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类的用户</span></span><br><span class="line">Pub_Derv d1;</span><br><span class="line">d<span class="number">1.</span><span class="built_in">pub_mem</span>();<span class="comment">// 正确</span></span><br><span class="line">Priv_Derv d2;</span><br><span class="line">d<span class="number">2.</span><span class="built_in">pub_mem</span>();<span class="comment">// 错误：受Priv_Derv派生列表中private的影响，不能访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类的派生类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived_from_Public</span> : <span class="keyword">public</span> Pub_Derv&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;<span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived_from_Private</span> : <span class="keyword">public</span> Priv_Derv&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;<span class="comment">// 错误：Base::prot_mem在Priv_Derv中是private的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>可通过<code>using</code>改变派生类继承的个别成员的可访问性：</p><ul><li><code>using</code>出现在类的<code>private</code>部分：能被类的成员、友元访问；</li><li><code>using</code>出现在类的<code>protected</code>部分：能被类的成员、友元和派生类访问；</li><li><code>using</code>出现在类的<code>public</code>部分：能被类的成员、友元、派生类和用户访问；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base&#123;</span><br><span class="line">  <span class="comment">// 使用private继承，所以默认情况下，继承来的pub_mem, prot_mem是Derived的private成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">using</span> <span class="title">Base::pub_mem</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 使用using后：Derived的用户、派生类均可访问pub_mem</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">using</span> Base::prot_mem;<span class="comment">// 使用using后：Derived的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="上行转换（派生类向基类）的可访问性"><a href="#上行转换（派生类向基类）的可访问性" class="headerlink" title="上行转换（派生类向基类）的可访问性"></a>上行转换（派生类向基类）的可访问性</h4><ol><li>派生类的用户：当且仅当D对B<code>public</code>继承，才能进行上行转换；</li><li>派生类D的成员和友元：无论D对B的继承方式，均可上行转换；</li><li>派生类D的派生类E，其成员和友元：当且仅当D对B<code>public</code>或<code>protected</code>继承，才能上行转换。</li></ol><h4 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h4><ul><li><p>友元关系不能传递和继承：对于友元的基类和派生类，不具备特殊访问能力。</p></li><li><p>每个类控制各自成员的访问权限：对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>;<span class="comment">// Base的友元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123;<span class="keyword">return</span> b.<span class="built_in">prot_mem</span>()&#125;;<span class="comment">// 正确：Pal是Base的友元</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s.prot_mem;&#125;<span class="comment">// 正确：Pal可访问派生类中，从Base继承的部分</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s.j;&#125;<span class="comment">// 错误：Pal不可访问派生类中，不属于基类的部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="struct和class默认继承保护级别"><a href="#struct和class默认继承保护级别" class="headerlink" title="struct和class默认继承保护级别"></a><code>struct</code>和<code>class</code>默认继承保护级别</h4><p>默认情况下，<code>class</code>定义的派生类采取<code>private</code>继承；<code>struct</code>定义的派生类采取<code>public</code>继承</p><h3 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h3><p>派生类的作用域，<strong>嵌套在其基类的作用域之内</strong>：</p><ol><li><p>如果一个名字在派生类的作用域内无法解析，则<strong>编译器向其外层基类中，不断递归寻找</strong>该名字定义，直到继承链的顶端。</p><blockquote><p>逻辑类似于：编译器在符号表中查找标识符。</p></blockquote></li><li><p>名字冲突：若出现同名，定义在派生类的名字，将隐藏定义在基类中的名字（即使参数列表不同，也会隐藏掉）</p><blockquote><p>可通过作用域运算符，使用隐藏的基类成员，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>:Base&#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_base_num</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> Base::mem;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h3 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h3><h4 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><p><strong>基类的析构函数必须定义为虚函数</strong>。</p><p>当<code>delete</code>一个动态分配对象的指针时，可能会出现：指针的静态类型与被删除对象的动态类型不符的情况（运行时多态）。因此需要定义为虚函数，实现虚构函数的动态绑定。</p><blockquote><p>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针时，将产生未定义的行为。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Quote</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Quote *itemP=<span class="keyword">new</span> Quote;</span><br><span class="line"><span class="keyword">delete</span> itemP;<span class="comment">// 调用Quote的析构函数</span></span><br><span class="line">itemP=<span class="keyword">new</span> Bulk_quote;<span class="comment">// 静态类型与动态类型不一致</span></span><br><span class="line"><span class="keyword">delete</span> itemP;<span class="comment">// 调用Bulk_quote的析构函数</span></span><br></pre></td></tr></table></figure><h4 id="合成拷贝控制"><a href="#合成拷贝控制" class="headerlink" title="合成拷贝控制"></a>合成拷贝控制</h4><p>未完待续…</p><h3 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h3><p>当希望在容器中存放具有继承关系的对象时，可采用<strong>智能指针</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;</span><br><span class="line">basket.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Quote&gt;(...));</span><br><span class="line">basket.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Bulk_quote&gt;(...));</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;basket.<span class="built_in">back</span>()-&gt;<span class="built_in">net_price</span>(<span class="number">15</span>)&lt;&lt;endl;</span><br><span class="line"><span class="comment">// basket存放的是shared_ptr，必须解引用才能获得运行net_price的对象</span></span><br></pre></td></tr></table></figure><blockquote><p>如果定义容器中直接存放基类对象，那么添加派生类时，其派生类部分将会被忽略掉。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ Primer </category>
          
          <category> Class Design Techniques </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS Lab1 实验笔记</title>
      <link href="/posts/48d27dfa.html"/>
      <url>/posts/48d27dfa.html</url>
      
        <content type="html"><![CDATA[<h1 id="总前言"><a href="#总前言" class="headerlink" title="总前言"></a>总前言</h1><p>操作系统是大二下学期的一门核心专业课，实验部分分为6个实验（Lab1 ~ Lab6）。采用增量式实验设计思想，每个实验包含的内核代码量在几百行左右，并提供了代码框架和代码示例，要求阅读源码、理解机制并补全核心代码。每个实验可以独立运行和评测，最后实现一个可以在MIPS平台上运行的小型操作系统。以此专题，纪念大二下的每个“备受折磨”的日夜，重温操作系统的核心理念。<br>实验代码仓库位于<a href="https://github.com/WenLiuyi/OS_on_MIPS">OS_on_MIPS</a>.</p><p>总流程：实验编写的操作系统代码在Linux系统中，通过Makefile组织，通过交叉编译产生可执行文件；再使用QEMU模拟器运行该可执行文件，实现MOS操作系统的运行。</p><h2 id="内核与启动"><a href="#内核与启动" class="headerlink" title="内核与启动"></a>内核与启动</h2><p><strong>内核</strong>是操作系统最核心的部分，负责与硬件直接交互，并为用户进程提供服务。在<strong>计算机启动时，内核需要被加载到内存中</strong>，但不宜放在磁盘（CPU无法直接从磁盘访问数据）或内存（易失性）中，因此放在一个<strong>非易失性存储器中（如ROM或FLASH）</strong>。不过，将操作系统直接放入ROM或FLASH会面临以下几个问题：</p><ol><li><strong>存储空间限制</strong>： ROM或FLASH的存储空间有限，无法存放较大的内核;</li><li><strong>只能启动一个操作系统</strong>： 若操作系统内核直接从ROM或FLASH启动，无法实现多重启动。</li><li><strong>移植性受限</strong>： 将所有硬件相关代码放入内核中，不利于系统的移植。</li></ol><h3 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h3><p>为了解决这些问题，设计者将<strong>硬件初始化工作独立为bootloader程序，并将其保存在ROM或FLASH中</strong>，而将操作系统内核保存在磁盘上。Bootloader工作分为两个阶段：</p><ol><li>Stage 1：硬件加电 -&gt; Stage 1 Bootloader（ROM&#x2F;FLASH中）</li></ol><ul><li>硬件初始化（如时钟、中断、内存等）；</li><li><strong>将Stage 2的代码加载到RAM中，并跳转到Stage 2的入口点</strong>。</li></ul><ol start="2"><li>Stage 2：Bootloader（RAM中）</li></ol><ul><li>初始化其他硬件设备</li><li>加载操作系统内核镜像到RAM</li><li>设置启动参数，并<strong>将控制权交给操作系统内核</strong></li></ul><ol start="3"><li>（不属于Bootloader）：</li></ol><p><img src="/posts/48d27dfa/image.png"></p><p>BootLoader的操作模式分为：<strong>启动加载模式</strong>（从本地存储器（如硬盘）加载内核镜像）和 <strong>下载模式</strong>（通过串口或网络等方式下载远程内核镜像）。</p><p>总结：Bootloader 是操作系统启动的第一步，负责<strong>硬件初始化和内核加载</strong>。</p><h3 id="QEMU模拟器"><a href="#QEMU模拟器" class="headerlink" title="QEMU模拟器"></a>QEMU模拟器</h3><p>在QEMU模拟环境中，由于QEMU模拟器提供bootloader的启动功能（模仿了YAMON的功能）；支持直接加载ELF内核的内存，因此上述都不是问题啦。我们的MOS操作系统，从跳转到内核入口开始的。</p><blockquote><p>疑问：bootloader如何找到内核入口点呢？</p><p>解答：Bootloader中的引导加载程序，会解析内核映像的信息，找到<strong>内核入口点地址</strong>，将其写入某个寄存器（如跳转寄存器）；通过执行跳转命令，CPU从该寄存器中读取地址，从而跳转至内核入口。</p></blockquote><h2 id="从零开始搭建MOS"><a href="#从零开始搭建MOS" class="headerlink" title="从零开始搭建MOS"></a>从零开始搭建MOS</h2><h3 id="构建内核：从make开始"><a href="#构建内核：从make开始" class="headerlink" title="构建内核：从make开始"></a>构建内核：从make开始</h3><h4 id="Makefile为内核地图"><a href="#Makefile为内核地图" class="headerlink" title="Makefile为内核地图"></a>Makefile为内核地图</h4><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>.mk</span><br><span class="line"></span><br><span class="line">target_dir := target <span class="comment">#MOS构建目标所在目录</span></span><br><span class="line">mos_elf :=<span class="variable">$(target_dir)</span>/mos <span class="comment">#最终需要生成的ELF可执行文件</span></span><br><span class="line">user_disk := <span class="variable">$(target_dir)</span>/fs.img <span class="comment">#MOS文件系统使用的磁盘镜像文件</span></span><br><span class="line">link_script := kernel.lds</span><br><span class="line"></span><br><span class="line">modules :=libinit kern <span class="comment">#需要生成的子模块</span></span><br><span class="line">objects :=<span class="variable">$(<span class="built_in">addsuffix</span> /*.o,<span class="variable">$(modules)</span>)</span> <span class="comment">#要编译出内核所依赖的所有目标文件（*.o）</span></span><br><span class="line"></span><br><span class="line">QEMU_FLAGS :=-cpu4Kc-m64-nographic-Mmalta\</span><br><span class="line">            $(shell[-f&#x27;<span class="variable">$(user_disk)</span>&#x27;] &amp;&amp;\</span><br><span class="line">            echo&#x27;-driveid=ide,file=<span class="variable">$(user_disk)</span>,if=ide,format=raw&#x27;) \</span><br><span class="line">            -no-reboot <span class="comment">#QEMU运行参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all $(modules) clean</span></span><br></pre></td></tr></table></figure><p>在命令行执行<code>make</code>后，在<code>target</code>目录下生成内核镜像文件<code>mos</code>，步骤如下：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">targets:=<span class="variable">$(mos_elf)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:<span class="variable">$(targets)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(modules)</span>:</span><br><span class="line">    <span class="variable">$(MAKE)</span>--directory=<span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(mos_elf)</span>: <span class="variable">$(modules)</span></span><br><span class="line">    <span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span>-o<span class="variable">$(mos_elf)</span>-N-T<span class="variable">$(link_script)</span> <span class="variable">$(objects)</span></span><br><span class="line">    <span class="comment"># 调用了链接器，将之前构建各模块产生的所有.o文件在linkerscript的指导下，链接到一起，产生最终的mos可执行文件</span></span><br></pre></td></tr></table></figure><h5 id="构建MOS依赖项"><a href="#构建MOS依赖项" class="headerlink" title="构建MOS依赖项"></a>构建MOS依赖项</h5><ol><li><p>执⾏<code>make</code>-&gt;构建⽬标<code>all</code>-&gt;构建<code>all</code>的依赖项<code>$(targets)</code>-&gt;构建<code>$(mos_elf)</code>-&gt;构建<code>$(modules)</code></p></li><li><p>对 <code>$(modules)</code> 中的每个⽬录执⾏⼀次 <code>$(MAKE) --directory=$@ .</code>，看⻅形如：<code>make[1]: Entering directory &#39;/home/git/xxxxxxxx/init&#39;</code> 的输出。<code>$(modules)</code>包含的内容如下：</p> <figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">modules :=lib init kern</span><br><span class="line">targets :=<span class="variable">$(mos_elf)</span></span><br><span class="line"></span><br><span class="line">lab-ge= <span class="variable">$(<span class="built_in">shell</span> [ <span class="string">&quot;$$(echo<span class="variable">$(lab)</span>_|cut-f1-d_)&quot;</span> -ge$(1)</span> ] &amp;&amp;echotrue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span>($(calllab-ge,3),true)</span><br><span class="line">    user_modules +=user/bare</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span>($(calllab-ge,4),true)</span><br><span class="line">    user_modules +=user</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span>($(calllab-ge,5),true)</span><br><span class="line">    user_modules +=fs</span><br><span class="line">targets +=fs-image</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">objects :=$(addsuffix/*.o, <span class="variable">$(modules)</span>)<span class="variable">$(<span class="built_in">addsuffix</span> /*.x,<span class="variable">$(user_modules)</span>)</span></span><br><span class="line">modules +=<span class="variable">$(user_modules)</span></span><br></pre></td></tr></table></figure><ul><li><code>$(modules)</code> 包含：<code>lib</code> ,<code>init</code> ,<code>kern</code> 这三个构建⽬标，分别对应依赖库、初始化代码和内核代码。</li><li><code>$(user_modules)</code>是一个可选的构建目标，它的构建取决于lab变量的值。</li></ul><p> 将组合好的<code>$(modules)</code>和<code>$(user_modules)</code>的内容对应的生成文件，赋值给<code>$(objects)</code></p></li></ol><h5 id="构建MOS"><a href="#构建MOS" class="headerlink" title="构建MOS"></a>构建MOS</h5><ol start="3"><li><p><code>$(mos_elf)</code> 构建：执⾏<code>$(LD) -o $(mos_elf) -N -T $(link_script) $(objects)</code></p><ul><li><code>-o --output</code> :设置输出⽂件名</li><li><code>-T --script</code> :读取链接脚本</li></ul><p> 使⽤<code>$(link_script)</code> 将<code>$(objects)</code> 链接，输出到<code>$(mos_elf)</code> 位置.</p></li><li><p>将组合好的 <code>$(modules)</code> 和<code>$(user_modules)</code> 的内容对应的⽣成⽂件赋值给<code>$(objects)</code></p><ul><li><code>objects</code> :将⽤户程序和内核程序的⽬标⽂件，分为不同的后缀保存;</li><li><code>modules</code>: 设置<code>$(modules)</code> 为所有需要依赖的构建⽬标</li></ul></li><li><p><code>$(mos_elf)</code> 下可查看内核⽂件</p></li></ol><h2 id="内核的入口"><a href="#内核的入口" class="headerlink" title="内核的入口"></a>内核的入口</h2><p>QEMU模拟器在加载内核时：按照可执行文件中所记录的地址，将内核中的代码、数据，加载到相应的位置，并将CPU控制权移交给内核。那么抛出两个问题：</p><ol><li>内核应该被放在哪里呢？</li><li>如何将内核加载到上述位置呢？</li></ol><h3 id="寻找内核的正确位置：MIPS内存布局"><a href="#寻找内核的正确位置：MIPS内存布局" class="headerlink" title="寻找内核的正确位置：MIPS内存布局"></a>寻找内核的正确位置：MIPS内存布局</h3><p><strong>内核放在<code>kseg0</code></strong>.</p><p>MIPS 体系结构的虚拟地址空间大小为<code>4GB</code>，布局如下图：<br><img src="/posts/48d27dfa/image-1.png"></p><table><thead><tr><th>区域</th><th>可用性</th><th>地址映射</th><th>存取方式</th></tr></thead><tbody><tr><td>kuseg</td><td>用户态</td><td>唯一可MMU的TLB：虚拟地址 -&gt; 物理地址</td><td>通过cache</td></tr><tr><td>kseg0</td><td>内核态</td><td>MMU将虚拟地址最高位清零，得到物理地址（连续映射至物理地址低512MB空间）</td><td>通过cache</td></tr><tr><td>kseg1</td><td>内核态</td><td>MMU将虚拟地址高三位清零，得到物理地址（连续映射至物理地址低512MB空间）</td><td>不通过cache（使用MIMO访问外设）</td></tr><tr><td>kseg2</td><td>只能在内核态使用</td><td>MMU的TLB：虚拟地址 -&gt; 物理地址</td><td>通过cache</td></tr></tbody></table><h3 id="控制加载地址：Linker-Script"><a href="#控制加载地址：Linker-Script" class="headerlink" title="控制加载地址：Linker Script"></a>控制加载地址：<code>Linker Script</code></h3><p>从上一节生成<code>MOS</code>的第3步中，可见：是使⽤<code>$(link_script)</code> 将<code>$(objects)</code> <strong>链接</strong>，生成可执行文件。这里的<code>$(link_script)</code>即<code>kernel.lds</code>，其中记录了各个节应该如何映射到段，以及各个段应该被加载到的位置。包括以下段：</p><ul><li><code>.text</code>：包含可执行文件中的代码</li><li><code>.data</code>：包含需要被初始化的全局变量和静态变量</li><li><code>.bss</code>：包含未初始化的全局变量和静态变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH(mips)   // 架构：MIPS</span><br><span class="line">ENTRY(_start)       // 设置MOS内核入口地址为：_start</span><br><span class="line"></span><br><span class="line">SECTIONS &#123;</span><br><span class="line">. = 0x80000000;</span><br><span class="line">.tlb_miss_entry : &#123;*(.text.tlb_miss_entry)&#125;</span><br><span class="line"></span><br><span class="line">. = 0x80000180;</span><br><span class="line">.exc_gen_entry : &#123;*(.text.exc_gen_entry)&#125;</span><br><span class="line"></span><br><span class="line">. = 0x80020000;     // .text段的加载地址</span><br><span class="line"></span><br><span class="line">.text : &#123; *(.text) &#125;</span><br><span class="line"></span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line"></span><br><span class="line">bss_start = .;</span><br><span class="line">.bss : &#123; *(.bss) &#125;</span><br><span class="line">bss_end = .;</span><br><span class="line">. = 0x80400000;</span><br><span class="line">end = . ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MOS内核入口：-start"><a href="#MOS内核入口：-start" class="headerlink" title="MOS内核入口：_start"></a>MOS内核入口：_start</h3><p>从上一小节可知：<code>kernel.lds</code>中设置了MOS内核入口<code>ENTRY(_start)</code>，对应<code>init/start.S</code>中的<code>_start</code>函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/asm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mmu.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line"><span class="title function_">EXPORT</span><span class="params">(_start)</span></span><br><span class="line">.<span class="built_in">set</span> at</span><br><span class="line">.<span class="built_in">set</span> reorder    <span class="comment">// 启用指令重排：MIPS编译器自动重排指令以优化性能，减少流水线阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清空 .bss 段：清零后跳转至clear_bss_done */</span></span><br><span class="line">la      v0, bss_start</span><br><span class="line">la      v1, bss_end</span><br><span class="line">clear_bss_loop:</span><br><span class="line">beq     v0, v1, clear_bss_done</span><br><span class="line">sb      zero, 0<span class="params">(v0)</span></span><br><span class="line">addiu   v0, v0, 1</span><br><span class="line">j       clear_bss_loop</span><br><span class="line"></span><br><span class="line">clear_bss_done:</span><br><span class="line"><span class="comment">/* 禁用中断 */</span></span><br><span class="line">mtc0    zero, CP0_STATUS</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将sp寄存器设置到：内核栈的起始地址 */</span></span><br><span class="line">       lasp, 0x80400000</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 跳转到 mips_init：内核初始化的入口点，执行内核的后续初始化工作 */</span></span><br><span class="line">jmips_init</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol><li>栈由高地址向低地址方向增长，<code>sp</code>应设置到栈底（即“顶”）；</li><li><code>j mips_init</code>采用<code>j</code>而非<code>jal</code>，是因为不存在返回的情况。</li></ol></blockquote><h2 id="内核初始化：mips-init函数"><a href="#内核初始化：mips-init函数" class="headerlink" title="内核初始化：mips_init函数"></a>内核初始化：mips_init函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MOS_INIT_OVERRIDDEN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;generated/init_override.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mips_init</span><span class="params">(u_int argc, <span class="type">char</span> **argv, <span class="type">char</span> **penv, u_int ram_low_size)</span> &#123;</span><br><span class="line">printk(<span class="string">&quot;init.c:\tmips_init() is called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>经过以上步骤，命令行执行<code>make run</code>，编译运行内核，MOS操作系统可以正常运行起来啦！</p><p>下一个Lab，将进入MIPS 4Kc的访存流程与内存映射布局，深入物理内存、虚拟内存的管理办法，以及TLB的清除与重填流程。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
          <category> BUAA OS lab </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++标准库：容器、动态内存、同步原语</title>
      <link href="/posts/b93a17fc.html"/>
      <url>/posts/b93a17fc.html</url>
      
        <content type="html"><![CDATA[<p>接上一篇知识。</p><h2 id="C-标准库容器"><a href="#C-标准库容器" class="headerlink" title="C++标准库容器"></a>C++标准库容器</h2><h3 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a><code>std::vector</code></h3><ul><li><code>std::vector</code> 是一种动态数组，可以根据需要自动调整大小，能够存储任意类型的元素。</li></ul><h4 id="向向量中添加元素"><a href="#向向量中添加元素" class="headerlink" title="向向量中添加元素"></a>向向量中添加元素</h4><ul><li><code>push_back</code> 和 <code>emplace_back</code> 都用于向向量中添加元素。<ul><li><code>emplace_back</code> 通常比 <code>push_back</code> 更高效，因为它直接在内存中创建元素，而不需要先构造一个临时对象然后再移动。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">point_vector.<span class="built_in">push_back</span>(<span class="built_in">Point</span>(<span class="number">35</span>, <span class="number">36</span>));  <span class="comment">// 使用 push_back 添加元素</span></span><br><span class="line">point_vector.<span class="built_in">emplace_back</span>(<span class="number">37</span>, <span class="number">38</span>);  <span class="comment">// 使用 emplace_back 添加元素</span></span><br></pre></td></tr></table></figure><h4 id="遍历向量"><a href="#遍历向量" class="headerlink" title="遍历向量"></a>遍历向量</h4><ul><li>直接&#x2F;<strong>用下标</strong>遍历元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Printing the items in point_vector:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; point_vector.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">  point_vector[i].<span class="built_in">PrintPoint</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="删除向量中的元素"><a href="#删除向量中的元素" class="headerlink" title="删除向量中的元素"></a>删除向量中的元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int_vector.<span class="built_in">erase</span>(int_vector.<span class="built_in">begin</span>() + <span class="number">2</span>);  <span class="comment">// 删除索引为 2 的元素</span></span><br><span class="line">int_vector.<span class="built_in">erase</span>(int_vector.<span class="built_in">begin</span>() + <span class="number">1</span>, int_vector.<span class="built_in">end</span>());  <span class="comment">// 删除索引从 1 到末尾的元素</span></span><br></pre></td></tr></table></figure><h4 id="使用-std-remove-if-删除符合条件的元素"><a href="#使用-std-remove-if-删除符合条件的元素" class="headerlink" title="使用 std::remove_if 删除符合条件的元素"></a>使用 <code>std::remove_if</code> 删除符合条件的元素</h4><ul><li><code>remove_if</code> 会将符合条件的元素移动到容器末尾，返回一个指向第一个符合条件元素的迭代器，然后通过 <code>erase</code> 实际删除这些元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">point_vector.<span class="built_in">erase</span>(</span><br><span class="line">    std::<span class="built_in">remove_if</span>(point_vector.<span class="built_in">begin</span>(), point_vector.<span class="built_in">end</span>(),</span><br><span class="line">                   [](<span class="type">const</span> Point &amp;point) &#123; <span class="keyword">return</span> point.<span class="built_in">GetX</span>() == <span class="number">37</span>; &#125;),</span><br><span class="line">    point_vector.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="std-set"><a href="#std-set" class="headerlink" title="std::set"></a><code>std::set</code></h3><ul><li><code>std::set</code> 是一个存储<strong>唯一元素</strong>的容器，且元素会自动按顺序排列。通常，<code>std::set</code> 使用<strong>红黑树</strong>来实现，确保元素在插入时能够保持<strong>有序</strong>。</li><li>支持插入、查找、删除等基本操作；</li><li><strong>不支持按索引访问，只能通过迭代器遍历</strong></li></ul><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><ul><li>通过 <code>insert</code> 和 <code>emplace</code> 两种方式向 <code>int_set</code> 集合中插入元素。<ul><li>其中 emplace 允许直接构造对象，而不需要先创建临时对象。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 insert 插入元素 1 到 5</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">  int_set.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 emplace 插入元素 6 到 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">6</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  int_set.<span class="built_in">emplace</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><ul><li>使用 <code>find</code> 函数查找元素，返回的是一个迭代器：如果找到了元素，返回的迭代器不等于 <code>end()</code>，否则等于 <code>end()</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">int</span>&gt;::iterator search = int_set.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (search != int_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Element 2 is in int_set.\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计数元素"><a href="#计数元素" class="headerlink" title="计数元素"></a>计数元素</h4><ul><li><code>count</code> 函数用于查找某个元素的个数，在 <code>std::set</code> 中，每个元素最多只能出现一次，所以返回值要么是 0（元素不存在），要么是 1（元素存在）。</li></ul><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><code>erase(int_set.find(9), int_set.end())</code> 用于删除从元素 9 开始直到集合末尾的所有元素。</p><ul><li>由于<code>set</code>有序，即为：删除大于等于9的元素</li></ul><h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::set&lt;<span class="type">int</span>&gt;::iterator it = int_set.<span class="built_in">begin</span>(); it != int_set.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">  std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 通过解引用迭代器访问元素</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Printing the elements of the iterator with a for-each loop:\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;elem : int_set) &#123;</span><br><span class="line">  std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-unordered-map"><a href="#std-unordered-map" class="headerlink" title="std::unordered_map"></a><code>std::unordered_map</code></h3><ul><li><code>std::unordered_map</code> 是一个<strong>哈希表</strong>实现的容器，用于存储键值对；每个键是唯一的；且容器中的元素不保证按任何特定顺序排列，而是根据哈希值分布存储。<ul><li>查找、插入和删除操作的平均时间复杂度为常数级别</li></ul></li><li>支持插入、查找、删除和<strong>迭代</strong>操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   <span class="comment">// 用于输出（打印）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span>  <span class="comment">// 包含 std::unordered_map 容器的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>     <span class="comment">// 包含 std::string 类型的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>    <span class="comment">// 包含 std::make_pair 等实用功能的头文件</span></span></span><br></pre></td></tr></table></figure><h4 id="插入元素-1"><a href="#插入元素-1" class="headerlink" title="插入元素"></a>插入元素</h4><ul><li><code>std::make_pair</code> 用于创建一个键值对。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="built_in">insert</span>(&#123;<span class="string">&quot;foo&quot;</span>, <span class="number">2</span>&#125;);  </span><br><span class="line">map.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&quot;jignesh&quot;</span>, <span class="number">445</span>));  </span><br><span class="line">map.<span class="built_in">insert</span>(&#123;&#123;<span class="string">&quot;spam&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;eggs&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;garlic rice&quot;</span>, <span class="number">3</span>&#125;&#125;);  <span class="comment">// 批量插入多个键值对</span></span><br><span class="line">map[<span class="string">&quot;bacon&quot;</span>] = <span class="number">5</span>;  <span class="comment">// 通过下标语法插入 &quot;bacon&quot; 键和 5 值</span></span><br></pre></td></tr></table></figure><h4 id="查找元素-1"><a href="#查找元素-1" class="headerlink" title="查找元素"></a>查找元素</h4><ul><li>通过迭代器可以访问到键值对，<code>result-&gt;first</code> 获取键，<code>result-&gt;second</code> 获取值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string, <span class="type">int</span>&gt;::iterator result = map.<span class="built_in">find</span>(<span class="string">&quot;jignesh&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (result != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Found key &quot;</span> &lt;&lt; result-&gt;first &lt;&lt; <span class="string">&quot; with value &quot;</span> &lt;&lt; result-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用auto关键字"><a href="#使用auto关键字" class="headerlink" title="使用auto关键字"></a>使用<code>auto</code>关键字</h3><ul><li><code>auto</code> 关键字用于告诉编译器<strong>根据变量的初始化表达式来推断变量的类型</strong>。这样，开发者不需要显式地指定类型，编译器会根据右侧的赋值表达式自动推导类型。这对于复杂的类型声明，尤其是模板类或容器类型，非常有用。</li></ul><h4 id="复杂类型的推导示例"><a href="#复杂类型的推导示例" class="headerlink" title="复杂类型的推导示例"></a>复杂类型的推导示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个模板类，它的名称非常长。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abcdefghijklmnopqrstuvwxyz</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Abcdefghijklmnopqrstuvwxyz</span>(T instance1, U instance2)</span><br><span class="line">      : <span class="built_in">instance1_</span>(instance1), <span class="built_in">instance2_</span>(instance2) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; instance1_ &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; instance2_ &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T instance1_;</span><br><span class="line">  U instance2_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个模板类实例的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Abcdefghijklmnopqrstuvwxyz&lt;T, T&gt; <span class="title">construct_obj</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Abcdefghijklmnopqrstuvwxyz</span>&lt;T, T&gt;(instance, instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Abcdefghijklmnopqrstuvwxyz&lt;<span class="type">int</span>, <span class="type">int</span>&gt; obj = <span class="built_in">construct_obj</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">auto</span> obj1 = <span class="built_in">construct_obj</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>);  <span class="comment">// 使用 auto 推导类型，无需写出长类名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复制与引用"><a href="#复制与引用" class="headerlink" title="复制与引用"></a>复制与引用</h4><ul><li><code>auto</code> <strong>默认会进行深拷贝</strong><ul><li>在此例中，<code>copy_int_values</code> 是 <code>int_values</code> 的一个副本，修改 <code>copy_int_values</code> 不会影响 <code>int_values</code></li><li>如果希望避免深拷贝，可以使用 <code>auto&amp;</code> 来创建一个引用，这样对 <code>ref_int_values</code> 的修改将直接影响 <code>int_values</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; int_values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// auto 会创建一个副本</span></span><br><span class="line"><span class="keyword">auto</span> copy_int_values = int_values;  <span class="comment">// 深拷贝 int_values</span></span><br><span class="line"><span class="comment">// 使用 auto&amp; 创建引用，避免深拷贝</span></span><br><span class="line"><span class="keyword">auto</span>&amp; ref_int_values = int_values;  <span class="comment">// 引用 int_values</span></span><br></pre></td></tr></table></figure><h4 id="用于迭代容器"><a href="#用于迭代容器" class="headerlink" title="用于迭代容器"></a>用于迭代容器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 auto 推导迭代器类型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-标准库动态内存"><a href="#C-标准库动态内存" class="headerlink" title="C++标准库动态内存"></a>C++标准库动态内存</h2><p>智能指针：是用于内存管理的一个数据结构，尤其是在没有内存管理内建机制（如垃圾回收）的语言中（例如 C++）。智能指针的主要功能是<strong>自动处理内存的分配与释放</strong>。在现代 C++ 标准库中，常用的智能指针有 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>，它们都在内部封装了原始指针，自动管理内存。</p><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a><code>std::unique_ptr</code></h3><ul><li>具有<strong>唯一所有权</strong>的特性。即同一个对象只能被一个 <code>std::unique_ptr</code> 管理，不能共享对象的所有权。</li><li>它<strong>无法进行拷贝</strong>，但可以通过 <code>std::move</code> 转移所有权。</li><li>当 <code>std::unique_ptr</code> 离开作用域时，它所管理的对象会被自动释放。这避免了手动释放内存时可能出现的错误（如内存泄漏）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span> <span class="comment">// 引入 unique_ptr 功能</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// 用于打印的字符串库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// 引入 std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Point</span>() : <span class="built_in">x_</span>(<span class="number">0</span>), <span class="built_in">y_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">x_</span>(x), <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SetX</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; x_ = x; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SetY</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123; y_ = y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x_;</span><br><span class="line">  <span class="type">int</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetXTo445</span><span class="params">(std::unique_ptr&lt;Point&gt;&amp; ptr)</span> </span>&#123;</span><br><span class="line">  ptr-&gt;<span class="built_in">SetX</span>(<span class="number">445</span>); <span class="comment">// 修改唯一指针指向的对象的 x 值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化 unique_ptr</span></span><br><span class="line">  std::unique_ptr&lt;Point&gt; u1; <span class="comment">// 空指针</span></span><br><span class="line">  std::unique_ptr&lt;Point&gt; u2 = std::<span class="built_in">make_unique</span>&lt;Point&gt;(); <span class="comment">// 默认构造函数</span></span><br><span class="line">  std::unique_ptr&lt;Point&gt; u3 = std::<span class="built_in">make_unique</span>&lt;Point&gt;(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 自定义构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 unique_ptr 是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (u1) &#123;</span><br><span class="line">    <span class="comment">// 这个条件不会成立，因为 u1 是空的</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;u1&#x27;s value of x is &quot;</span> &lt;&lt; u1-&gt;<span class="built_in">GetX</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (u2) &#123;</span><br><span class="line">    <span class="comment">// 这个条件会成立，因为 u2 包含一个有效的 Point 实例</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;u2&#x27;s value of x is &quot;</span> &lt;&lt; u2-&gt;<span class="built_in">GetX</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印 unique_ptr 是否为空</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Pointer u1 is &quot;</span> &lt;&lt; (u1 ? <span class="string">&quot;not empty&quot;</span> : <span class="string">&quot;empty&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Pointer u2 is &quot;</span> &lt;&lt; (u2 ? <span class="string">&quot;not empty&quot;</span> : <span class="string">&quot;empty&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Pointer u3 is &quot;</span> &lt;&lt; (u3 ? <span class="string">&quot;not empty&quot;</span> : <span class="string">&quot;empty&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// unique_ptr 不能被拷贝（没有拷贝构造函数），因此以下代码不能编译：</span></span><br><span class="line">  <span class="comment">// std::unique_ptr&lt;Point&gt; u4 = u3;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是可以通过 std::move 转移所有权</span></span><br><span class="line">  std::unique_ptr&lt;Point&gt; u4 = std::<span class="built_in">move</span>(u3);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为所有权已经转移到 u4，u3 现在为空</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Pointer u3 is &quot;</span> &lt;&lt; (u3 ? <span class="string">&quot;not empty&quot;</span> : <span class="string">&quot;empty&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Pointer u4 is &quot;</span> &lt;&lt; (u4 ? <span class="string">&quot;not empty&quot;</span> : <span class="string">&quot;empty&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传递 unique_ptr 给函数</span></span><br><span class="line">  <span class="built_in">SetXTo445</span>(u4);  <span class="comment">// 通过引用传递，确保所有权没有改变</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印 u4 的 x 值，确认所有权未变且对象已被修改</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Pointer u4&#x27;s x value is &quot;</span> &lt;&lt; u4-&gt;<span class="built_in">GetX</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a><code>std::shared_ptr</code></h3><p><code>std::shared_ptr</code> 实现了<strong>共享所有权</strong>的机制，这意味着多个 <code>shared_ptr</code> 实例可以指向同一个对象，且每个 <code>shared_ptr</code> 的析构都会降低对象的引用计数。当引用计数降至 0 时，所管理的对象会被自动销毁。</p><ul><li><strong>拷贝构造与赋值</strong>：<code>std::shared_ptr</code> 支持拷贝构造和赋值操作符。这些操作会导致引用计数（<code>use_count</code>）增加。</li><li><strong>转移所有权</strong>：可以通过 <code>std::move</code> 转移 <code>shared_ptr</code> 的所有权，使得原来的 <code>shared_ptr</code> 成为“空”指针，而新的 <code>shared_ptr</code> 会接管原来的对象。</li></ul><h4 id="创建和初始化shared-ptr"><a href="#创建和初始化shared-ptr" class="headerlink" title="创建和初始化shared_ptr"></a>创建和初始化<code>shared_ptr</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Point&gt; s1;</span><br><span class="line">std::shared_ptr&lt;Point&gt; s2 = std::<span class="built_in">make_shared</span>&lt;Point&gt;();</span><br><span class="line">std::shared_ptr&lt;Point&gt; s3 = std::<span class="built_in">make_shared</span>&lt;Point&gt;(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h4 id="引用计数与拷贝构造"><a href="#引用计数与拷贝构造" class="headerlink" title="引用计数与拷贝构造"></a>引用计数与拷贝构造</h4><ul><li>初始时，<code>s3</code> 是唯一一个指向 <code>Point</code> 对象的指针，因此引用计数为 1；将 <code>s3</code> 拷贝给 <code>s4</code> 后，引用计数增加到 2，表示 <code>s3</code> 和 <code>s4</code> 都指向同一块内存。<ul><li>修改 <code>s3</code> 的数据会影响 <code>s4</code>，因为它们共享同一个对象。<strong><code>shared_ptr</code> 确保当任何一个指针修改对象时，所有的共享指针都会看到这个变化</strong>。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;s3 use_count: &quot;</span> &lt;&lt; s<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 1</span></span><br><span class="line">std::shared_ptr&lt;Point&gt; s4 = s3;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;s3 use_count after copy: &quot;</span> &lt;&lt; s<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 2</span></span><br></pre></td></tr></table></figure><h4 id="转移所有权"><a href="#转移所有权" class="headerlink" title="转移所有权"></a>转移所有权</h4><ul><li>使用 <code>std::move</code> 可以将 <code>s5</code> 的所有权转移到 <code>s6</code>。此时，<code>s5</code> 变为空指针，而 <code>s6</code> 接管了原来 <code>s5</code> 所指向的对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Point&gt; s6 = std::<span class="built_in">move</span>(s5);</span><br></pre></td></tr></table></figure><h4 id="通过引用和右值引用传递shared-ptr"><a href="#通过引用和右值引用传递shared-ptr" class="headerlink" title="通过引用和右值引用传递shared_ptr"></a>通过引用和右值引用传递<code>shared_ptr</code></h4><ul><li>通过<strong>引用</strong>传递时，原始的 <code>shared_ptr</code> 仍然<strong>保持所有权</strong>；</li><li>通过<strong>右值引用</strong>传递时，<strong>所有权会转移到函数内的指针</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_ptr_via_ref</span><span class="params">(std::shared_ptr&lt;Point&gt; &amp;point)</span> </span>&#123; point-&gt;<span class="built_in">SetX</span>(<span class="number">15</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify_ptr_via_rvalue_ref</span><span class="params">(std::shared_ptr&lt;Point&gt; &amp;&amp;point)</span> </span>&#123;point-&gt;<span class="built_in">SetY</span>(<span class="number">645</span>);&#125;</span><br></pre></td></tr></table></figure><h2 id="C-标准库同步原语"><a href="#C-标准库同步原语" class="headerlink" title="C++标准库同步原语"></a>C++标准库同步原语</h2><p>在并发编程中，同步原语用于管理线程之间的访问顺序、共享资源的访问权限以及防止数据竞争。在 C++ 标准库（STL）中，提供了一些同步原语，用于实现线程安全和协调多个线程的执行。以下是 STL 中常见的同步原语及其说明。</p><h3 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a><code>std::mutex</code></h3><ul><li><code>std::mutex</code> 提供了基本的互斥锁功能，保证在<strong>同一时刻只有一个线程可以访问</strong>共享资源。<ul><li><code>lock()</code> 和 <code>unlock()</code> 用于手动获取和释放锁，确保线程在访问共享资源时是独占的。</li><li>C++11 引入了 <code>std::lock_guard</code> 和 <code>std::unique_lock</code> 等工具，这些工具通过 RAII（资源获取即初始化）模式简化了锁的管理，自动管理锁的获取和释放。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 包含 std::cout 用于打印输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>    <span class="comment">// 包含 std::mutex 库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>   <span class="comment">// 包含 std::thread 库，用于创建线程</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局计数变量和一个 mutex 互斥锁</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">std::mutex m;  <span class="comment">// 声明并默认初始化一个互斥锁 m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add_count 函数允许线程原子性地将 count 增加 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在访问共享资源 count 之前，首先获取锁</span></span><br><span class="line">  m.<span class="built_in">lock</span>();</span><br><span class="line">  count += <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 操作完成后，释放锁</span></span><br><span class="line">  m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建两个线程，分别运行 add_count 函数</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(add_count)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(add_count)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待两个线程完成执行</span></span><br><span class="line">  t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印 count 的最终值</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Printing count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-scoped-lock"><a href="#std-scoped-lock" class="headerlink" title="std::scoped_lock"></a><code>std::scoped_lock</code></h3><ul><li><code>std::scoped_lock</code> 是 C++11 引入的一个新的互斥锁包装类，它遵循 RAII（资源获取即初始化）范式。在构造 <code>std::scoped_lock</code> 对象时，它会<strong>自动获取指定的互斥锁，并在作用域结束时自动释放锁</strong>。<ul><li>这使得锁的管理变得更加简洁和安全，避免了手动调用 <code>lock()</code> 和 <code>unlock()</code> 的错误;</li><li>它确保互斥锁会被自动释放，无论函数如何退出（正常结束或抛出异常）;</li><li><code>std::scoped_lock</code> 会<strong>按传递顺序</strong>自动获取多个锁：如果需要在同一作用域中锁定多个互斥锁，可以使用 <code>std::scoped_lock</code> 来确保按正确的顺序获取锁，避免死锁问题。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 包含 std::cout 用于打印输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>    <span class="comment">// 包含 std::mutex 库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>   <span class="comment">// 包含 std::thread 库，用于创建线程</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局计数变量和一个互斥锁</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">std::mutex m;  <span class="comment">// 声明并默认初始化一个互斥锁 m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add_count 函数允许线程原子性地将 count 增加 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 std::scoped_lock 自动获取互斥锁 m</span></span><br><span class="line">  <span class="function">std::scoped_lock <span class="title">slk</span><span class="params">(m)</span></span>;  <span class="comment">// 锁 m，作用范围在 slk 对象的生命周期内</span></span><br><span class="line">  count += <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 在函数结束时，slk 销毁，mutex m 被自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建两个线程，分别运行 add_count 函数</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(add_count)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(add_count)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待两个线程完成执行</span></span><br><span class="line">  t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印 count 的最终值</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Printing count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件变量std-condition-variable"><a href="#条件变量std-condition-variable" class="headerlink" title="条件变量std::condition_variable"></a>条件变量<code>std::condition_variable</code></h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><ul><li>条件变量使得线程可以在满足某个条件之前挂起（等待）；</li><li>通知机制：线程可以<strong>通过条件变量，通知等待线程某个条件的改变</strong>（例如，条件变为true）；</li></ul><h4 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h4><ol><li><code>std::mutex</code>：用于保护共享资源，防止数据竞争；</li><li><code>std::condition_variable</code>：用于实现条件同步；</li><li><code>std::unique_lock</code>：配合条件变量使用，允许线程在等待期间释放锁，以便其他线程可以访问共享资源；当条件满足时，<code>unique_lock</code> 会重新获得锁。</li></ol><ul><li><code>cv.wait(lk, pred)</code>：该函数<strong>使线程阻塞，直到 <code>pred</code> 条件返回 <code>true</code></strong>。在等待期间，线程会释放锁，当条件成立时会重新获取锁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;                    <span class="comment">// 全局计数器</span></span><br><span class="line">std::mutex m;                     <span class="comment">// 互斥锁，用于同步对 count 的访问</span></span><br><span class="line">std::condition_variable cv;       <span class="comment">// 条件变量，用于线程间同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于增加 count 值并在 count == 2 时通知等待线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_count_and_notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::scoped_lock <span class="title">slk</span><span class="params">(m)</span></span>;        <span class="comment">// 自动加锁和解锁</span></span><br><span class="line">  count += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">2</span>) &#123;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>();              <span class="comment">// 如果 count 达到 2，通知一个等待线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程函数，等待 count == 2 时继续执行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waiter_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lk</span><span class="params">(m)</span></span>;         <span class="comment">// 使用 unique_lock 管理锁</span></span><br><span class="line">  cv.<span class="built_in">wait</span>(lk, []&#123; <span class="keyword">return</span> count == <span class="number">2</span>; &#125;);  <span class="comment">// 等待条件成立，count == 2</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Printing count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl; <span class="comment">// 打印 count 值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建三个线程，t1 和 t2 会运行 add_count_and_notify，t3 运行 waiter_thread</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(add_count_and_notify)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(add_count_and_notify)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t3</span><span class="params">(waiter_thread)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等待线程执行完成</span></span><br><span class="line">  t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-STL-示例：读写锁（RWLock）模拟"><a href="#C-STL-示例：读写锁（RWLock）模拟" class="headerlink" title="C++ STL 示例：读写锁（RWLock）模拟"></a>C++ STL 示例：读写锁（RWLock）模拟</h3><p>C++ 标准库（STL）并没有直接提供读写锁（Reader-Writer Lock）的实现，但可以通过 <code>std::shared_mutex</code>、<code>std::shared_lock</code> 和 <code>std::unique_lock</code> 来模拟读写锁的行为。</p><h4 id="关键组件-1"><a href="#关键组件-1" class="headerlink" title="关键组件"></a>关键组件</h4><ol><li><code>std::shared_mutex m</code>：共享互斥锁，保护对 <code>count</code> 变量的访问</li><li>共享锁（<code>std::shared_lock</code>）：在 <code>read_value()</code> 中，<code>std::shared_lock</code> 允许多个线程同时读取 <code>count</code>，但不能同时进行写入操作。</li><li>独占锁（<code>std::unique_lock</code>）：在 <code>write_value()</code> 中，<code>std::unique_lock</code> 确保每次只有一个线程可以修改 <code>count</code>，从而避免了数据竞争。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量 count 和共享互斥锁 m，用于保护 count</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">std::shared_mutex m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取值的函数，使用 std::shared_lock 获取共享锁，表示读操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::shared_lock <span class="title">lk</span><span class="params">(m)</span></span>;  <span class="comment">// 获取共享锁</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Reading value &quot;</span> + std::<span class="built_in">to_string</span>(count) + <span class="string">&quot;\n&quot;</span> &lt;&lt; std::flush;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入值的函数，使用 std::unique_lock 获取独占锁，表示写操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lk</span><span class="params">(m)</span></span>;  <span class="comment">// 获取独占锁</span></span><br><span class="line">  count += <span class="number">3</span>;  <span class="comment">// 对 count 进行修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建六个线程，两个执行写操作，四个执行读操作</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(read_value)</span></span>;  <span class="comment">// 读取操作</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(write_value)</span></span>; <span class="comment">// 写入操作</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t3</span><span class="params">(read_value)</span></span>;  <span class="comment">// 读取操作</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t4</span><span class="params">(read_value)</span></span>;  <span class="comment">// 读取操作</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t5</span><span class="params">(write_value)</span></span>; <span class="comment">// 写入操作</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t6</span><span class="params">(read_value)</span></span>;  <span class="comment">// 读取操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待所有线程完成</span></span><br><span class="line">  t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">3.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">4.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">5.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">6.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ Primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello，world！C++中的引用、移动语义、模板、包装类、迭代器和命名空间</title>
      <link href="/posts/73de9bd.html"/>
      <url>/posts/73de9bd.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hello，world！今天是2025年3月12日，这是我站的第一篇博客，也是我重新踏上自学CS之路的起点！</p><p>回想已流逝的两年半多本科时光，很多课程因为时间紧、任务重，学得像个“快餐式”程序员——知识点匆匆下肚，消化得却不咋样；ppt上的知识点背了一打，实践起来“一问三不知”。猛然发现，自己像个“半成品”，代码写得像“面条”，bug多得像“打地鼠”。</p><p>恰逢找到第一个日常实习，初尝真实的工作环境。实习之余决定重启学习，重新修炼“代码内功”。</p><p>从哪里开始呢？第一站是C++的基本语法。之前刷算法题时用过C++，每次没有类、没有封装、没有 unit test、没有 Makefile、没有 Git，唯一的优点是它确实能跑，缺点是“能跑”的补集；大三上做过一个4000行代码的Qt小项目，实现简单图像识别与参量的自动化计算（可见：<a href="https://github.com/WenLiuyi/fiber_Analysis">https://github.com/WenLiuyi/fiber_Analysis</a> ）现已经成功打包成exe文件，可在Windows系统执行。但那过程简直像“渡劫”——装了几十个 G 的 Visual Studio，每次打开那笨重的 IDE，配置环境像“解谜游戏”，编译错误像“天书”，代码结构像“迷宫”。每次debug都像在玩“找茬”，头大得能顶个西瓜！但这些“坑”让我明白，自己的知识储备还像个“小池塘”，远远不够用。</p><p>这条路不会像“Hello, world!”那么简单，但最好的时机，就是现在！从“零”开始，走向“无穷大”！（超级感谢<a href="https://csdiy.wiki/">CS自学指南</a>）</p><h1 id="C-预备知识"><a href="#C-预备知识" class="headerlink" title="C++预备知识"></a>C++预备知识</h1><ul><li><a href="https://en.cppreference.com/w/cpp/language/reference">References</a></li><li><a href="https://en.cppreference.com/w/cpp/utility/move">std::move</a></li><li><a href="https://en.cppreference.com/w/cpp/language/move_constructor">Move Constructors</a>和<a href="https://en.cppreference.com/w/cpp/language/move_assignment">Move Assignment Operators</a></li></ul><h2 id="引用和移动"><a href="#引用和移动" class="headerlink" title="引用和移动"></a>引用和移动</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>引用是 C++ 中的一种机制，用来创建变量的别名。通过引用，<strong>多个名字可以指向同一块内存区域</strong>。引用通常用于函数参数的传递、改动数据的追踪以及提升性能等场景。</p><ul><li>初始化：引用必须在声明时初始化，并且一旦绑定到一个变量后不能改变指向另一个变量。</li><li>参考传递（Pass by Reference）：引用是一种传递方式，允许函数修改调用者的变量值。</li><li>性能优化：通过引用避免了数据的复制，提高了效率，尤其是在传递大数据结构时。</li></ul><h4 id="引用的声明"><a href="#引用的声明" class="headerlink" title="引用的声明"></a>引用的声明</h4><p>引用的声明使用的是单个 &amp; 符号。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;  <span class="comment">// b 是 a 的引用</span></span><br></pre></td></tr></table></figure><p>这意味着 b 只是 a 的另一个名字，a 和 b 都指向同一个内存位置。如果我们修改 b，实际上就是修改 a 的值。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个接受 int 引用并将其值增加 3 的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_three</span><span class="params">(<span class="type">int</span> &amp;a)</span> </span>&#123; </span><br><span class="line">    a = a + <span class="number">3</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;   <span class="comment">// 定义一个整型变量 a</span></span><br><span class="line">    <span class="type">int</span> &amp;b = a;   <span class="comment">// b 是 a 的引用，它指向 a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 b 的值，此时 b 的值为 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b is &quot;</span> &lt;&lt; b &lt;&lt; std::endl;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 add_three 函数，传入 a 的引用，a 的值将被修改</span></span><br><span class="line">    <span class="built_in">add_three</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 a 的新值，add_three 函数已将 a 增加了 3</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a is &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-移动语义"><a href="#C-移动语义" class="headerlink" title="C++移动语义"></a>C++移动语义</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>移动语义是 C++ 中的一种重要特性，旨在提高程序的性能，特别是在处理大型数据结构时。移动语义通过避免不必要的深拷贝，使得对象之间的数据转移更加高效。与传统的拷贝操作不同，移动操作<strong>通过“转移所有权”的方式，使得对象的资源能够直接从一个对象转移到另一个对象，而不是复制数据</strong>。<br>移动语义的核心概念在于区分 左值（lvalue） 和 右值（rvalue）：</p><ul><li>左值（lvalue）： 是指向<strong>内存中某个位置的对象</strong>，可以持久存在。</li><li>右值（rvalue） 是<strong>临时对象</strong>，通常用于表示临时的、不再需要的对象。</li><li>性能提升：使用 <code>std::move</code> 可以避免不必要的深拷贝。特别是当我们操作如 <code>std::vector</code>、<code>std::string</code> 等需要大量内存的容器时，移动比拷贝要高效得多。</li></ul><h4 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h4><ol><li><code>std::move</code>： <code>std::move</code> 不是“移动”操作本身，而是将一个对象标记为可以被移动的状态，实际上它只是一个类型转换操作，<strong>将左值转换为右值</strong>。之后，移动构造函数或移动赋值操作符会将对象的所有权，从一个对象转移到另一个对象。</li><li>右值引用（Rvalue Reference）： 右值引用是使用 <code>&amp;&amp;</code> 语法声明的引用，它绑定到一个右值上。通过右值引用，我们可以通过移动语义避免不必要的拷贝。</li></ol><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个接收右值引用作为参数的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_add_three_and_print</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;&amp;vec)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; vec1 = std::<span class="built_in">move</span>(vec);  <span class="comment">// 使用 std::move 转移 vec 的所有权</span></span><br><span class="line">  vec<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">3</span>);  <span class="comment">// 向 vec1 添加一个元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;item : vec1) &#123;</span><br><span class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 打印 vec1 中的元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个接收右值引用的函数，但不获取所有权，仅修改数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_three_and_print</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; &amp;&amp;vec)</span> </span>&#123;</span><br><span class="line">  vec.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;item : vec) &#123;</span><br><span class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// &#x27;a&#x27; 是左值</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; int_array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;  <span class="comment">// 定义一个整数向量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 int_array 的数据转移到另一个向量</span></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; stealing_ints = std::<span class="built_in">move</span>(int_array);  <span class="comment">// 通过 std::move 将所有权转移</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; &amp;&amp;rvalue_stealing_ints = std::<span class="built_in">move</span>(stealing_ints);  <span class="comment">// 使用右值引用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 虽然所有权已转移，但仍然可以访问原来数据（不过此时的行为不可预测）</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Printing from stealing_ints: &quot;</span> &lt;&lt; stealing_ints[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将右值引用传入函数，转移所有权</span></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; int_array2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Calling move_add_three_and_print...\n&quot;</span>;</span><br><span class="line">  <span class="built_in">move_add_three_and_print</span>(std::<span class="built_in">move</span>(int_array2));  <span class="comment">// 使用 std::move 转移 int_array2 的所有权</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意：一旦调用了 move_add_three_and_print，int_array2 中的数据就不再属于它，不能再访问</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; int_array2[1] &lt;&lt; std::endl;  // 访问已转移数据的行为未定义（可能崩溃）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 另一种情况，使用右值引用，但不获取所有权</span></span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; int_array3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Calling add_three_and_print...\n&quot;</span>;</span><br><span class="line">  <span class="built_in">add_three_and_print</span>(std::<span class="built_in">move</span>(int_array3));  <span class="comment">// 这里只是修改数据，不转移所有权</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于没有转移所有权，int_array3 仍然有效</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Printing from int_array3: &quot;</span> &lt;&lt; int_array3[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><p>移动构造函数用于在<strong>创建新对象</strong>时，将一个已有对象的资源从源对象“移动”到目标对象。通过 std::move，源对象的资源将被转移给新对象，而源对象的状态会被置为无效。</p><h4 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h4><p>移动赋值运算符用于将一个已有对象的资源从一个对象转移到另一个<strong>已存在的对象</strong>中。在此过程中，目标对象会接管源对象的资源，而源对象则失去对这些资源的所有权。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><ol><li><code>Person</code>类包含3个构造函数：一个默认构造函数；一个带有右值引用参数的构造函数用于通过移动资源来初始化对象；一个移动构造函数</li><li>移动构造函数<code>Person(Person &amp;&amp;person)</code>：接受一个右值引用 <code>Person &amp;&amp;person</code>，通过 <code>std::move</code> 转移 <code>nicknames_</code> 和 <code>age_</code> 的所有权来创建新对象；</li><li>移动赋值运算符<code>Person &amp;operator=(Person &amp;&amp;other)</code>：将 <code>other</code> 对象的资源转移到当前对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>() : <span class="built_in">age_</span>(<span class="number">0</span>), <span class="built_in">nicknames_</span>(&#123;&#125;), <span class="built_in">valid_</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动构造函数：接受右值引用，转移资源</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">uint32_t</span> age, std::vector&lt;std::string&gt; &amp;&amp;nicknames)</span><br><span class="line">      : <span class="built_in">age_</span>(age), <span class="built_in">nicknames_</span>(std::<span class="built_in">move</span>(nicknames)), <span class="built_in">valid_</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复制构造函数已删除，不允许复制</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Person &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Person &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动构造函数：从另一个 Person 对象移动资源</span></span><br><span class="line">  <span class="built_in">Person</span>(Person &amp;&amp;person)</span><br><span class="line">      : <span class="built_in">age_</span>(person.age_), <span class="built_in">nicknames_</span>(std::<span class="built_in">move</span>(person.nicknames_)),</span><br><span class="line">        <span class="built_in">valid_</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;调用 Person 类的移动构造函数。\n&quot;</span>;</span><br><span class="line">    person.valid_ = <span class="literal">false</span>; <span class="comment">// 移动后，源对象的状态变为无效</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动赋值运算符：转移资源</span></span><br><span class="line">  Person &amp;<span class="keyword">operator</span>=(Person &amp;&amp;other) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;调用 Person 类的移动赋值运算符。\n&quot;</span>;</span><br><span class="line">    age_ = other.age_;</span><br><span class="line">    nicknames_ = std::<span class="built_in">move</span>(other.nicknames_);</span><br><span class="line">    valid_ = <span class="literal">true</span>;</span><br><span class="line">    other.valid_ = <span class="literal">false</span>; <span class="comment">// 源对象的状态变为无效</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">GetAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 nicknames_ 中的某个字符串的引用</span></span><br><span class="line">  <span class="function">std::string &amp;<span class="title">GetNicknameAtI</span><span class="params">(<span class="type">size_t</span> i)</span> </span>&#123; <span class="keyword">return</span> nicknames_[i]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PrintValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (valid_) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;对象有效。\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;对象无效。\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">uint32_t</span> age_;</span><br><span class="line">  std::vector&lt;std::string&gt; nicknames_;</span><br><span class="line">  <span class="type">bool</span> valid_; <span class="comment">// 追踪对象的有效性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 Person 对象 andy，并初始化其昵称和年龄</span></span><br><span class="line">  <span class="function">Person <span class="title">andy</span><span class="params">(<span class="number">15445</span>, &#123;<span class="string">&quot;andy&quot;</span>, <span class="string">&quot;pavlo&quot;</span>&#125;)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;打印 andy 的有效性: &quot;</span>;</span><br><span class="line">  andy.<span class="built_in">PrintValid</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 std::move 调用移动赋值运算符，将 andy 的内容转移到 andy1</span></span><br><span class="line">  Person andy1;</span><br><span class="line">  andy1 = std::<span class="built_in">move</span>(andy);  <span class="comment">// 调用移动赋值运算符</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;打印 andy1 的有效性: &quot;</span>;</span><br><span class="line">  andy<span class="number">1.</span><span class="built_in">PrintValid</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;打印 andy 的有效性: &quot;</span>;</span><br><span class="line">  andy.<span class="built_in">PrintValid</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 std::move 调用移动构造函数，将 andy1 的内容转移到 andy2</span></span><br><span class="line">  <span class="function">Person <span class="title">andy2</span><span class="params">(std::move(andy1))</span></span>;  <span class="comment">// 调用移动构造函数</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;打印 andy2 的有效性: &quot;</span>;</span><br><span class="line">  andy<span class="number">2.</span><span class="built_in">PrintValid</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;打印 andy1 的有效性: &quot;</span>;</span><br><span class="line">  andy<span class="number">1.</span><span class="built_in">PrintValid</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下代码会因为复制构造函数被删除而无法编译</span></span><br><span class="line">  <span class="comment">// Person andy3;</span></span><br><span class="line">  <span class="comment">// andy3 = andy2;  // 编译错误，不能使用复制赋值运算符</span></span><br><span class="line">  <span class="comment">// Person andy4(andy2);  // 编译错误，不能使用复制构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板是C++中的一种语言特性，它允许你编写可以与多种数据类型一起工作的代码，而无需指定具体的类型。C++中既可以创建模板函数，也可以创建模板类。</p><h3 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h3><ul><li>模板类使得类能够与不同的数据类型一起工作，而不需要为每个数据类型编写不同的类实现。</li></ul><h4 id="基本模板类"><a href="#基本模板类" class="headerlink" title="基本模板类"></a>基本模板类</h4><p>下面是一个基本的模板类 Foo，它可以存储一个模板类型的元素，并在调用 print 函数时打印该元素的值：</p><ul><li>T 是模板参数，表示类 Foo 可以存储任何类型的值。var_ 是存储该值的成员变量，print 函数用来打印该值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(T var) : <span class="built_in">var_</span>(var) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; var_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T var_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用多个模板参数"><a href="#使用多个模板参数" class="headerlink" title="使用多个模板参数"></a>使用多个模板参数</h4><p>模板类不仅支持单一模板参数，还可以支持多个模板参数。以下是一个接受两个不同类型参数的模板类 Foo2：</p><ul><li>Foo2 类存储了两个不同类型的元素 var1_ 和 var2_，并在 print 函数中打印它们。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo2</span>(T var1, U var2) : <span class="built_in">var1_</span>(var1), <span class="built_in">var2_</span>(var2) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; var1_ &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; var2_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T var1_;</span><br><span class="line">    U var2_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="特化模板类"><a href="#特化模板类" class="headerlink" title="特化模板类"></a>特化模板类</h4><p>C++允许为特定类型提供模板类的专门实现，这称为模板类特化。以下是一个模板类 <code>FooSpecial</code>，它的 <code>print</code> 函数根据模板参数类型的不同执行不同的操作：</p><ul><li>在这个例子中，<code>FooSpecial</code> 是一个模板类，当它的类型是 <code>float</code> 时，<code>print</code> 函数会输出不同的信息（”hello float!”），而其他类型则按照常规输出存储的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooSpecial</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooSpecial</span>(T var) : <span class="built_in">var_</span>(var) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; var_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T var_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 针对float类型的模板特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooSpecial</span>&lt;<span class="type">float</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooSpecial</span>(<span class="type">float</span> var) : <span class="built_in">var_</span>(var) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello float! &quot;</span> &lt;&lt; var_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> var_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用非类型模板参数"><a href="#使用非类型模板参数" class="headerlink" title="使用非类型模板参数"></a>使用非类型模板参数</h4><p>除了类型作为模板参数外，还可以使用常量（如整数）作为模板参数。以下是一个例子，其中 <code>Bar</code> 类接受一个整数作为模板参数：</p><ul><li><code>Bar</code> 类接受一个整数模板参数 T，并在 <code>print_int</code> 函数中输出该常量值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bar</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_int</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;print int: &quot;</span> &lt;&lt; T &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用模板类型 int 实例化 Foo 类</span></span><br><span class="line"><span class="function">Foo&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Calling print on Foo&lt;int&gt; a(3): &quot;</span>;</span><br><span class="line">a.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模板类型 float 实例化 Foo 类</span></span><br><span class="line"><span class="function">Foo <span class="title">b</span><span class="params">(<span class="number">3.4f</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Calling print on Foo b(3.4f): &quot;</span>;</span><br><span class="line">b.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用两个不同模板类型实例化 Foo2 类</span></span><br><span class="line"><span class="function">Foo2&lt;<span class="type">int</span>, <span class="type">float</span>&gt; <span class="title">c</span><span class="params">(<span class="number">3</span>, <span class="number">3.2f</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Calling print on Foo2&lt;int, float&gt; c(3, 3.2f): &quot;</span>;</span><br><span class="line">c.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化 FooSpecial 类，分别使用 int 和 float 类型</span></span><br><span class="line"><span class="function">FooSpecial&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Calling print on FooSpecial&lt;int&gt; d(5): &quot;</span>;</span><br><span class="line">d.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">FooSpecial&lt;<span class="type">float</span>&gt; <span class="title">e</span><span class="params">(<span class="number">4.5</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Calling print on FooSpecial&lt;float&gt; e(4.5): &quot;</span>;</span><br><span class="line">e.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用非类型模板参数实例化 Bar 类</span></span><br><span class="line">Bar&lt;<span class="number">150</span>&gt; f;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Calling print_int on Bar&lt;150&gt; f: &quot;</span>;</span><br><span class="line">f.<span class="built_in">print_int</span>();</span><br></pre></td></tr></table></figure><h3 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h3><h4 id="基本模板函数"><a href="#基本模板函数" class="headerlink" title="基本模板函数"></a>基本模板函数</h4><p>C++模板函数的语法允许函数接受<strong>任何类型的数据</strong>作为参数，而不需要显式地定义数据类型。可以使用 <code>template</code> 关键字来定义模板函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数接受两种相同类型的参数，返回它们的和。<code>typename T</code> 是模板参数，表示函数可以接受任意类型的数据。</p><h4 id="多个模板参数"><a href="#多个模板参数" class="headerlink" title="多个模板参数"></a>多个模板参数</h4><p>模板函数可以接受多个模板参数。例如，下面的 <code>print_two_values</code> 函数接受两种不同类型的参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_two_values</span><span class="params">(T a, U b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数输出两个不同类型的参数。</p><h4 id="特化模板函数"><a href="#特化模板函数" class="headerlink" title="特化模板函数"></a>特化模板函数</h4><p>C++允许<strong>为特定类型提供模板函数的专门实现</strong>，这称为模板特化。在下面的例子中，<code>print_msg</code> 函数通常打印“Hello world!”，但当类型为 <code>float</code> 时，打印不同的信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_msg</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world!\n&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对float类型的模板特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; </span><br><span class="line"><span class="type">void</span> <span class="built_in">print_msg</span>&lt;<span class="type">float</span>&gt;() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;print_msg called with float type!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用非类模板参数"><a href="#使用非类模板参数" class="headerlink" title="使用非类模板参数"></a>使用非类模板参数</h4><p>模板的参数不一定非要是类型。你也可以使用常量表达式作为模板参数，例如下面的 add3 函数，它根据传入的布尔值决定如何修改参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> T&gt; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add3</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数通过模板参数 T 决定是将 a 加上3还是不变。</p><h4 id="调用模板函数"><a href="#调用模板函数" class="headerlink" title="调用模板函数"></a>调用模板函数</h4><p>下面是如何调用模板函数的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 add&lt;int&gt; 和 add&lt;float&gt;</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Printing add&lt;int&gt;(3, 5): &quot;</span> &lt;&lt; <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Printing add&lt;float&gt;(2.8, 3.7): &quot;</span> &lt;&lt; <span class="built_in">add</span>&lt;<span class="type">float</span>&gt;(<span class="number">2.8</span>, <span class="number">3.7</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断（函数根据传入的参数类型推断模板类型）</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Printing add(3, 5): &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 print_two_values</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Printing print_two_values&lt;int, float&gt;(3, 3.2): &quot;</span>;</span><br><span class="line"><span class="built_in">print_two_values</span>&lt;<span class="type">int</span>, <span class="type">float</span>&gt;(<span class="number">3</span>, <span class="number">3.2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 print_msg</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Calling print_msg&lt;int&gt;(): &quot;</span>;</span><br><span class="line"><span class="built_in">print_msg</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Calling print_msg&lt;float&gt;(): &quot;</span>;</span><br><span class="line"><span class="built_in">print_msg</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 add3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Printing add3&lt;true&gt;(3): &quot;</span> &lt;&lt; <span class="built_in">add3</span>&lt;<span class="literal">true</span>&gt;(<span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Printing add3&lt;false&gt;(3): &quot;</span> &lt;&lt; <span class="built_in">add3</span>&lt;<span class="literal">false</span>&gt;(<span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>在C++中，包装类是一种<strong>管理资源的类</strong>。资源可以是内存、文件句柄、网络连接等。包装类通常采用RAII（Resource Acquisition Is Initialization，资源获取即初始化）编程技巧，这意味着<strong>资源的生命周期与类实例的生命周期绑定</strong>。当包装类的实例被构造时，它会获取相应的资源；而当实例被销毁时，资源会被释放。</p><h3 id="IntPtrManager实现"><a href="#IntPtrManager实现" class="headerlink" title="IntPtrManager实现"></a><code>IntPtrManager</code>实现</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IntPtrManager</span>() &#123;</span><br><span class="line">  ptr_ = <span class="keyword">new</span> <span class="type">int</span>;   <span class="comment">// 分配内存</span></span><br><span class="line">  *ptr_ = <span class="number">0</span>;        <span class="comment">// 初始化值为 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">IntPtrManager</span>(<span class="type">int</span> val) &#123;</span><br><span class="line">  ptr_ = <span class="keyword">new</span> <span class="type">int</span>;   <span class="comment">// 分配内存</span></span><br><span class="line">  *ptr_ = val;      <span class="comment">// 初始化为给定的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul><li>析构函数通过 <code>delete</code> 释放 <code>ptr_</code> 指向的内存。为了防止在移动语义中出现悬挂指针，它会检查 <code>ptr_ </code>是否为 <code>nullptr</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">IntPtrManager</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr_;  <span class="comment">// 释放资源</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移动构造函数和移动赋值操作符"><a href="#移动构造函数和移动赋值操作符" class="headerlink" title="移动构造函数和移动赋值操作符"></a>移动构造函数和移动赋值操作符</h4><ul><li>由于<strong>包装类通常不允许复制</strong>，因为复制可能会导致双重删除资源（即两个对象管理同一资源），因此：删除了拷贝构造函数和拷贝赋值操作符，并实现了移动构造函数和移动赋值操作符。</li><li>移动构造函数：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IntPtrManager</span>(IntPtrManager&amp;&amp; other) &#123;</span><br><span class="line">  ptr_ = other.ptr_;  <span class="comment">// 转移资源</span></span><br><span class="line">  other.ptr_ = <span class="literal">nullptr</span>;  <span class="comment">// 设置源对象为无效状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动赋值操作符：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IntPtrManager &amp;<span class="keyword">operator</span>=(IntPtrManager&amp;&amp; other) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ptr_ == other.ptr_) &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr_;  <span class="comment">// 释放当前资源</span></span><br><span class="line">  &#125;</span><br><span class="line">  ptr_ = other.ptr_;  <span class="comment">// 转移资源</span></span><br><span class="line">  other.ptr_ = <span class="literal">nullptr</span>;  <span class="comment">// 设置源对象为无效状态</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除拷贝构造函数和拷贝赋值操作符"><a href="#删除拷贝构造函数和拷贝赋值操作符" class="headerlink" title="删除拷贝构造函数和拷贝赋值操作符"></a>删除拷贝构造函数和拷贝赋值操作符</h4><ul><li>为了避免两个对象管理同一资源，IntPtrManager 类的拷贝构造函数和拷贝赋值操作符被删除：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IntPtrManager</span>(<span class="type">const</span> IntPtrManager&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝构造</span></span><br><span class="line">IntPtrManager&amp; <span class="keyword">operator</span>=(<span class="type">const</span> IntPtrManager&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 禁止拷贝赋值</span></span><br></pre></td></tr></table></figure><h2 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h2><p>C++ 迭代器是<strong>指向容器中元素的对象</strong>，可以用来遍历容器中的元素。迭代器在 C++ STL 中被广泛使用，通常用来访问和修改容器中的元素。指针就是一种常见的迭代器，它可以用来遍历 C 风格数组。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol><li><strong>解引用运算符（*）</strong>：返回当前迭代器指向元素的值；</li><li><strong>自增运算符（++）</strong>：将迭代器指向下一个元素。<br>STL 中的容器（如 vector, set, unordered_map）都支持迭代器。</li></ol><h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>实现自定义双向链表（DLL）迭代器的示例。</p><ol><li>双向链表节点（<code>Node</code>）<br>定义一个节点结构体 Node，它包含指向前一个节点和后一个节点的指针，以及存储的值。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="built_in">Node</span>(<span class="type">int</span> val) </span><br><span class="line">    : <span class="built_in">next_</span>(<span class="literal">nullptr</span>), <span class="built_in">prev_</span>(<span class="literal">nullptr</span>), <span class="built_in">value_</span>(val) &#123;&#125;</span><br><span class="line">  Node* next_;</span><br><span class="line">  Node* prev_;</span><br><span class="line">  <span class="type">int</span> value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义迭代器（<code>DLLIterator</code>）<br>实现自定义迭代器，用于遍历双向链表。该迭代器类实现了以下操作符：</li></ol><ul><li>前缀自增运算符 <code>++iter</code>：将迭代器指向下一个节点。</li><li>后缀自增运算符 <code>iter++</code>：类似于前缀自增运算符，但<strong>返回值是递增前的迭代器</strong>。</li><li>等于运算符 <code>==</code> 和不等于运算符 <code>!=</code>：判断两个迭代器是否指向同一个节点。</li><li>解引用运算符 <code>*</code>：返回当前节点的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLLIterator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DLLIterator</span>(Node* head) </span><br><span class="line">      : <span class="built_in">curr_</span>(head) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    DLLIterator&amp; <span class="keyword">operator</span>++() &#123;     <span class="comment">// 前缀自增</span></span><br><span class="line">      curr_ = curr_-&gt;next_;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DLLIterator <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;    <span class="comment">// 后缀自增</span></span><br><span class="line">      DLLIterator temp = *<span class="keyword">this</span>;</span><br><span class="line">      ++*<span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> DLLIterator &amp;itr) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> itr.curr_ == <span class="keyword">this</span>-&gt;curr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> DLLIterator &amp;itr) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> itr.curr_ != <span class="keyword">this</span>-&gt;curr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>*() &#123;</span><br><span class="line">      <span class="keyword">return</span> curr_-&gt;value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Node* curr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>双向链表（<code>DLL</code>）</li></ol><ul><li><code>DLL</code> 类实现了一个基本的双向链表，并且提供了 <code>Begin</code> 和 <code>End</code> 函数返回迭代器，用于遍历链表。<br><code>Begin()</code> 返回指向链表头部的迭代器。<br><code>End()</code> 返回指向链表末尾之后位置的迭代器（即 <code>nullptr</code>）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLL</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DLL</span>() : <span class="built_in">head_</span>(<span class="literal">nullptr</span>), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DLL</span>() &#123;      <span class="comment">// 析构函数</span></span><br><span class="line">      Node *current = head_;</span><br><span class="line">      <span class="keyword">while</span>(current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        Node *next = current-&gt;next_;</span><br><span class="line">        <span class="keyword">delete</span> current;</span><br><span class="line">        current = next;</span><br><span class="line">      &#125;</span><br><span class="line">      head_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InsertAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">      Node *new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">      new_node-&gt;next_ = head_;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (head_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        head_-&gt;prev_ = new_node;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      head_ = new_node;</span><br><span class="line">      size_ += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLLIterator <span class="title">Begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">DLLIterator</span>(head_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLLIterator <span class="title">End</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">DLLIterator</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* head_;</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用迭代器遍历双向链表</li></ol><ul><li>在 <code>main</code> 函数中，我们演示了如何使用自定义的双向链表迭代器来遍历链表。<ul><li>插入元素：通过 <code>InsertAtHead</code> 插入元素。</li><li>遍历链表：通过前缀和后缀自增运算符来遍历链表。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  DLL dll;</span><br><span class="line">  dll.<span class="built_in">InsertAtHead</span>(<span class="number">6</span>);</span><br><span class="line">  dll.<span class="built_in">InsertAtHead</span>(<span class="number">5</span>);</span><br><span class="line">  dll.<span class="built_in">InsertAtHead</span>(<span class="number">4</span>);</span><br><span class="line">  dll.<span class="built_in">InsertAtHead</span>(<span class="number">3</span>);</span><br><span class="line">  dll.<span class="built_in">InsertAtHead</span>(<span class="number">2</span>);</span><br><span class="line">  dll.<span class="built_in">InsertAtHead</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用前缀自增运算符遍历</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Printing elements of the DLL dll via prefix increment operator\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (DLLIterator iter = dll.<span class="built_in">Begin</span>(); iter != dll.<span class="built_in">End</span>(); ++iter) &#123;</span><br><span class="line">    std::cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用后缀自增运算符遍历</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Printing elements of the DLL dll via postfix increment operator\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (DLLIterator iter = dll.<span class="built_in">Begin</span>(); iter != dll.<span class="built_in">End</span>(); iter++) &#123;</span><br><span class="line">    std::cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>命名空间（namespace） 用于将标识符（如函数、类型、变量等）组织成逻辑上的组，并避免不同标识符之间的命名冲突。命名空间通过<strong>限定作用域</strong>，防止命名冲突。例如，C++ 标准库使用 std 命名空间，因此我们通过 std::cout 来访问输出流对象 cout。:: 操作符用于指定作用域，帮助区分不同命名空间中的标识符。</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><ul><li>若在同一命名空间中调用，可以直接使用函数名；而如果在其他命名空间中调用，需要通过作用域解析运算符 <code>::</code> 指定完整的命名空间路径。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ABC &#123;</span><br><span class="line">  <span class="keyword">namespace</span> DEF &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uses_spam</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Hello from uses_spam: &quot;</span>;</span><br><span class="line">      ABC::<span class="built_in">spam</span>(a);  <span class="comment">// 必须通过 ABC::spam 来调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间冲突"><a href="#命名空间冲突" class="headerlink" title="命名空间冲突"></a>命名空间冲突</h3><ul><li>如果多个命名空间中有相同名字的函数或变量，它们依然可以共存，因为它们的全名（即带有命名空间的名字）是不同的。</li></ul><h3 id="using-关键字的使用"><a href="#using-关键字的使用" class="headerlink" title="using 关键字的使用"></a>using 关键字的使用</h3><p><code>using</code> 关键字可以将命名空间或命名空间中的特定成员引入当前作用域。它有两个常见用法：</p><ul><li><strong>引入整个命名空间</strong>：使得命名空间中的所有成员在当前作用域内可以直接使用，而不需要指定命名空间名。</li><li><strong>引入特定成员</strong>：仅将命名空间中的某个成员引入当前作用域。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> B;  <span class="comment">// 引入整个 B 命名空间</span></span><br><span class="line"><span class="keyword">using</span> C::eggs;  <span class="comment">// 引入 C 命名空间中的 eggs 函数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ Primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
